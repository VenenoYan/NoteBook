##[IO端口](http://www.cnblogs.com/Anker/p/3265058.html)
* 
从CPU出来的总线(地址总线、数据总线、控制总线等)，这些线上都有接口(存储器接口、DMA接口等)。
* 
外部设备想要接入，就需要把自己的接口和总线上的接口对接，所以总线上才会有各种设备：内存、硬盘、鼠标等
* 
总线上的**接口电路中有多个寄存器(就是端口)**，访问设备就是访问绑定的端口，由端口转交给设备。
* 
一个系统会有多个外设，一个接口电路中有多个寄存器，每个端口就需要一个地址。
* 
每个连接到I/O总线上的设备都会绑定寄存器即端口或者I/O地址，也就可以映射到所谓的端口。
* 
如今I/O端口更多的被映射到物理地址空间：端口、内存、缓冲等等都需要唯一的标志符！
    * 
所以会占用物理地址空间，32位不一定4G！=====》统一编址
* 
cat /proc/ioports：查看端口分配信息

##[端口复用](http://www.zhihu.com/question/32163005/answer/55772739)
1. 
水平触发（level-triggered，默认）——只要满足条件，就触发一个事件(只要有数据没有被获取，内核就不断通知你)，本次不处理下次还提醒；=====本次可以不管
1. 
边缘触发（edge-triggered）——每当状态变化时，触发一个事件，如果不处理下次不提醒。=====必须管

* 
[select](http://www.cnblogs.com/Anker/archive/2013/08/14/3258674.html):
    * 
最大连接数：1024；可以配置
    * 
只告诉有无数据，而不告诉那个fd，所以要遍历；====如果很多，那不是效率低
    * 
不支持多线程
    * 
它会修改传入的文件描述符数组，所以每次重新传入新的数组，以前的不可再次使用；下次在传入新的；即传入一次传出一次，那么就是说两个拷贝，效率低；
    * 
过程：
        * 
使用copy_from_user从用户空间拷贝fd_set到内核空间
        * 
注册回调函数__pollwait
        * 
遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll）
        * 
以tcp_poll为例，其核心实现就是__pollwait，也就是上面注册的回调函数。
        * 
pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll来说，其等待队列是sk->sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。
        * 
poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。
        * 
如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。
        * 
把fd_set从内核空间拷贝到用户空间。
* 
[poll](http://www.cnblogs.com/Anker/archive/2013/08/15/3261006.html)
    * 
它会修改传入的文件描述符数组，所以每次重新传入新的数组，以前的不可再次使用；
    * 
只告诉有无数据及多少个变的，而不告诉那个fd，所以要遍历；====如果很多，那不是效率低
    * 
但是它解决了select最大个数的限制；使用链表，所以最大个数不限；同时它不需要三个位图，一个数据结构即可
    * 
过程：poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用pollfd结构而不是select的fd_set结构，其他的都差不多。
1. 
[epoll](http://www.cnblogs.com/Anker/archive/2013/08/17/3263780.html)
    * 
需要三个调用：第一个的参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议
    * 
最大个数不限
    * 
内核不修改，只需要传数组一次即可；
* 
综上：
    * 
select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。
    * 
select、poll中内核会修改传进来的数组，所以会在内核/用户层之间拷贝数据，效率不好；epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。
    * select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。
    * 
select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。


[返回目录](README.md)