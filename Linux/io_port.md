##[IO端口](http://www.cnblogs.com/Anker/p/3265058.html)
* 
从CPU出来的总线(地址总线、数据总线、控制总线等)，这些线上都有接口(存储器接口、DMA接口等)。
* 
外部设备想要接入，就需要把自己的接口和总线上的接口对接，所以总线上才会有各种设备：内存、硬盘、鼠标等
* 
总线上的**接口电路中有多个寄存器(就是端口)**，访问设备就是访问绑定的端口，由端口转交给设备。
* 
一个系统会有多个外设，一个接口电路中有多个寄存器，每个端口就需要一个地址。
* 
每个连接到I/O总线上的设备都会绑定寄存器即端口或者I/O地址，也就可以映射到所谓的端口。
* 
如今I/O端口更多的被映射到物理地址空间：端口、内存、缓冲等等都需要唯一的标志符！
    * 
所以会占用物理地址空间，32位不一定4G！=====》统一编址
* 
cat /proc/ioports：查看端口分配信息

##[端口复用](http://www.zhihu.com/question/32163005/answer/55772739)
* 
select:
    * 
最大连接数：1024；可以配置
    * 
只告诉有无数据，而不告诉那个fd，所以要遍历；====如果很多，那不是效率低
    * 
不支持多线程
    * 
它会修改传入的文件描述符数组，所以每次重新传入新的数组，以前的不可再次使用；
* 
poll
    * 
它会修改传入的文件描述符数组，所以每次重新传入新的数组，以前的不可再次使用；
    * 
只告诉有无数据，而不告诉那个fd，所以要遍历；====如果很多，那不是效率低
    * 
但是它解决了select最大个数的限制；使用链表，所以最大个数不限；
1. 
epoll
    * 
需要三个调用
    * 
最大个数不限
    * 
内核不修改，只需要传数组一次即可；
* 
综上：select、poll中内核会修改传进来的数组，所以会在内核/用户层之间拷贝数据，效率不好；epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。


[返回目录](README.md)