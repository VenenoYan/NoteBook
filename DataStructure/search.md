#查找：
* 
####静态查找：只查找是否在表中
* 
####动态查找：增、删节点

#常用算法
###1. 折半查找又称二分查找
* 
思想：在有序表中查找，不断的折半！
* 
实现
```C++
//顺序表：数组
int bin_search(SStable ST,keyType key)
{
    low = 1;high=ST.length;
    while(low<=high)
    {
        mid = (low+high)/2;
        if(ST[mid]<key)
            low = mid;
        else if(ST[mid]>key)
            high = mid;
        else
            return mid;
    }
}
```
* 
分析：在查找成功的情况下和判定树的深度有关：比较次数至多 floor(log2(n))+1，平均：log2(n+1)-1

###2.分块查找、索引顺序查找
* 
思想：在顺序查找基础上建立一个索引表：对所有的元素分块，索引表就是对块的索引，记录块号起始位置和块中最大关键字，先在索引表中找块号，然后在该块中查找即可！

###3.[二叉排序、二叉平衡树](BST.md)

###4.B：B-树、B+树、B*树.
####4.1 B-树又称多路平衡查找树
**一颗m阶的B-树：**就是任一个节点的子树最大m个即最多含有m-1个关键字
* 
每个节点至多有m颗子树(即最多m-1个关键字)，
* 
根节点如果不是终端节点，那么至少有两颗子树；
* 
除了根节点外的每个非叶子节点至少ceil(m/2)颗子树(即ceil(m/2)-1个关键字)。
* 
所有的叶子节点在同一层级上，且不带数据（可以认为是查找失败）；
* 
除叶子节点外的每个节点有关键字列表和指向子树的指针，关键字形成的范围是子树
<br>
```
1、所以B树的添加永远是在最底层的非叶子节点
2、根节点不是终端节点：【2，m】颗子树即【1，m-1】个关键字
3、非叶子节点：【ceil(m/2),m】颗子树即【ceil(m/2)-1,m-1】个关键字
```

####4.1.1 B树查找：
B树一般是存储在硬盘中，查找的过程分两步：找节点，找关键字；先在磁盘上查找节点，然后将节点读入内存，顺序查找或者二分查找对应的关键字，如果没有则进入对应的子树中继续查找；如果到空节点说明没有找到；

####4.1.2 B树插入：【小心多于m个子树】
* 
因为m阶B-树的定义，每次插入一定是底层节点，每个普通节点【ceil(m/2) , m】颗子树即【ceil(m/2)-1 , m-1】个关键字，所以插入时要判断是否超出m-1个关键字，如果是需要**分裂**
* 
分裂（向上分裂）：把关键字插入到对应节点中，该节点关键字个数超出m-1===》分裂。
    * 
由于叶子节点需要在同一层级上，所以向上分裂
    * 
将节点分成三部分：左半部(可以保存在原始节点中)、右半部（新建一个节点保存）、ceil(m/2)
    * 
左半部和右半部留下，将ceil(m/2)插入到父节点；
    * 
如果父节点中关键字个数不大于m-1正常，如果超过了，则继续向上分裂，直至树高加1；

####4.1.1 B树删除：【小心小于个ceil(m/2)子树】
* 
删除非终端节点：
    * 
如果左子树中关键字个数大于ceil(m/2) - 1，则从左子树拿走最大的值，递归处理左子树
    * 
如果右子树中关键字个数大于ceil(m/2) - 1，则从右子树拿走最小的值，递归处理右子树
    * 
如果两颗子树关键字个数均为ceil(m/2) - 1，则合并两个子节点
* 
删除终端节点：
    * 
若关键字所在节点中关键字总数大于ceil(m/2) - 1，直接删除；
    * 
若总数不大于ceil(m/2) - 1，则跟相邻兄弟借：
        * 
兄弟够借：
###5.[哈希](http://blog.csdn.net/chenhuajie123/article/details/9210091)：一个关键字对应一个存储位置
* 
最大优点：**能够在O(1)内找到某一元素**

数组的特点是：寻址容易，插入和删除困难；而链表的特点是：寻址困难，插入和删除容易。<br>那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构?====》哈希表

在计算机程序中，如果需要在一秒种内查找上千条记录通常使用哈希表（例如拼写检查器)哈希表的速度明显比树快，树的操作通常需要O(N)的时间级。哈希表不仅速度快，编程实现也相对容易。
* 
冲突：关键字不同，哈希地址相同。冲突不可避免
* 
根据设定的哈希函数(5.1)和处理冲突(5.2)的方法将关键字映射到一个地址集上。
####5.1.1直接定址法
* 
直接根据关键字得到哈希地址：H(key)=key/a*key+b
* 
冲突少，但是地址集与关键字集大小相同，使用较少。
####5.1.2数字分析法
* 
以关键字的某些位组成哈希地址
####5.1.3平方取中法
* 
取关键字平方后的中间几位为哈希地址
####5.1.4折叠法
* 
将关键字分割为位数相同的几部分，然后取叠加和作为哈希地址
####5.1.5除留余数法
* 
对某个小于哈希表表长的数p取余得到的为哈希地址：取余前可以折叠、平方等。p的选择至关重要
####5.1.6随机数法
* 
取关键字的随机函数值为哈希地址。<HR>
####5.2.1开放定址法
* 
根据增量序列来不断得到新的地址：1，-1,4,-4，...
*   
容易产生冲突聚集
####5.2.2 再哈希法
* 
针对冲突再使用一个新的哈希函数计算
* 
不易产生冲突聚集，但增加计算时间
####5.2.3 链地址法
* 
建立一个链表数组，每个链表代表一种可能，所有相同的hash值都放到链表尾部即可。
####5.2.4 公共溢出区
* 
针对冲突再建立一个溢出区，所有冲突放在此处。

###6.[红黑树](http://blog.csdn.net/chenhuajie123/article/details/11951777)
* 
性质：是平衡二叉树的一种
    * 
所有节点非红即黑
    * 
所有红节点的子节点都是黑的
    * 
根节点是黑的
    * 
叶子节点(NIL指针，仅代表树在此结束)和NULL节点是黑的
    * 
对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点。
#### 使一棵n个结点的红黑树始终保持了logn的高度，从根到叶子的最长的可能路径不多于最短的可能路径的两倍长：注意到性质2导致了路径不能有两个毗连的红色节点就足够了。<br>最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质4所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。

####6.1 红黑树插入的几种情况：
红黑树保证最深不会比最浅两倍
* 
情况0：当前无节点，自己是根节点-----------》直接着黑色即可
* 情况1：父亲是黑色-------------------------------》直接插入即可

　　　　　以上两种情况都是不用修复红黑树的！<br>
　　　　　但存在下面三种需要修复的情况：**要插入节点的父节点肯定为红色而且父亲还有黑色父节点**
* 
情况2：父亲是红色
    * 
叔叔y是红色的：爷爷肯定是黑的！
        * 
方案：父节点和叔叔节点涂黑，祖父结点涂红，把当前结点指向祖父节点；重新开始算法。
    * 
叔叔y是黑色的，且自己是右孩子
        * 
方案：父节点做为新的当前节点，以新当前节点为支点左旋。
    * 
叔叔y是黑色的，且自己是左孩子
        * 
方案：父节点变为黑色，祖父节点变为红色，在祖父节点为支点右旋。

####6.2 红黑树删除的几种情况。
* 情况1：
x的兄弟w是红色的。
* 情况2：
x的兄弟w是黑色的，且w的俩个孩子都是黑色的。
* 情况3：
x的兄弟w是黑色的，且w的左孩子是红色，w的右孩子是黑色。
* 情况4：
x的兄弟w是黑色的，且w的右孩子是红色的。

所以为了使插入、或删除结点后的树依然维持为一棵新的红黑树，
那就要做**三方面**的工作：
* 0
首先要查找到结点要插入／删除的位置，然后进行插入／删除
* 1
部分结点颜色，重新着色
* 2
调整部分指针的指向，即左旋、右旋。

[返回目录](README.md)