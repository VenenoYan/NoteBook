#查找：
* 
####静态查找：只查找是否在表中
* 
####动态查找：增、删节点

#常用算法
###1. 折半查找
* 
思想：在有序表中查找，不断的折半！
* 
实现
```C++
//顺序表：数组
int bin_search(SStable ST,keyType key)
{
    low = 1;high=ST.length;
    while(low<=high)
    {
        mid = (low+high)/2;
        if(ST[mid]<key)
            low = mid;
        else if(ST[mid]>key)
            high = mid;
        else
            return mid;
    }
}
```
* 
分析：在查找成功的情况下和判定树的深度有关：比较次数至多 floor(log2(n))+1，平均：log2(n+1)-1

###2.分块查找、索引顺序查找
* 
思想：在顺序查找基础上建立一个索引表：对所有的元素分块，索引表就是对块的索引，记录块号起始位置和块中最大关键字，先在索引表中找块号，然后在该块中查找即可！

###3.[二叉排序、二叉平衡树](BST.md)

###4.B-树和B+树
####4.1 B-树
* 
思想：一颗m阶的B-树：每个节点至多有m课子树，除了根节点外每个节点至少m/2课子树。除叶子节点外的每个节点有关键字列表和指向子树的指针，关键字形成的范围是子树

###5.[哈希](http://blog.csdn.net/chenhuajie123/article/details/9210091)：一个关键字对应一个存储位置
数组的特点是：寻址容易，插入和删除困难；而链表的特点是：寻址困难，插入和删除容易。<br>那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构?====》哈希表

* 
冲突：关键字不同，哈希地址相同。冲突不可避免
* 
根据设定的哈希函数(5.1)和处理冲突(5.2)的方法将关键字映射到一个地址集上。
####5.1.1直接定址法
* 
直接根据关键字得到哈希地址：H(key)=key/a*key+b
* 
冲突少，但是地址集与关键字集大小相同，使用较少。
####5.1.2数字分析法
* 
以关键字的某些位组成哈希地址
####5.1.3平方取中发
* 
取关键字平方后的中间几位为哈希地址
####5.1.4折叠法
* 
将关键字分割为位数相同的几部分，然后取叠加和作为哈希地址
####5.1.5除留余数法
* 
对某个小于哈希表表长的数p取余得到的为哈希地址：取余前可以折叠、平方等。p的选择至关重要
####5.1.6随机数法
* 
取关键字的随机函数值为哈希地址。<HR>
####5.2.1开放定址法
* 
根据增量序列来不断得到新的地址：1，-1,4,-4，...
*   
容易产生冲突聚集
####5.2.2 再哈希法
* 
针对冲突再使用一个新的哈希函数计算
* 
不易产生冲突聚集，但增加计算时间
####5.2.3 链地址法
* 
建立一个链表数组，每个链表代表一种可能，所有相同的hash值都放到链表尾部即可。
####5.2.4 公共溢出区
* 
针对冲突再建立一个溢出区，所有冲突放在此处。

###6.[红黑树](http://blog.csdn.net/chenhuajie123/article/details/11951777)
* 
性质：是平衡二叉树的一种
    * 
所有节点非红即黑
    * 
所有红节点的子节点都是黑的
    * 
根节点是黑的
    * 
叶子节点(NIL指针，仅代表树在此结束)和NULL节点是黑的
    * 
对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点。
#### 使一棵n个结点的红黑树始终保持了logn的高度，从根到叶子的最长的可能路径不多于最短的可能路径的两倍长：注意到性质2导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质4所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。

####6.1 红黑树插入的几种情况：
* 情况1： 
 z的叔叔y是红色的。
* 情况2：
z的叔叔y是黑色的，且z是右孩子
* 情况3：
z的叔叔y是黑色的，且z是左孩子

####6.2 红黑树删除的几种情况。
* 情况1：
x的兄弟w是红色的。
* 情况2：
x的兄弟w是黑色的，且w的俩个孩子都是黑色的。
* 情况3：
x的兄弟w是黑色的，且w的左孩子是红色，w的右孩子是黑色。
* 情况4：
x的兄弟w是黑色的，且w的右孩子是红色的。

所以为了使插入、或删除结点后的树依然维持为一棵新的红黑树，
那就要做俩方面的工作：
* 1
部分结点颜色，重新着色
* 2
调整部分指针的指向，即左旋、右旋。