#查找：
* 
####静态查找：只查找是否在表中
* 
####动态查找：增、删节点

#常用算法
###1. 折半查找
* 
思想：在有序表中查找，不断的折半！
* 
实现
```C++
//顺序表：数组
int bin_search(SStable ST,keyType key)
{
    low = 1;high=ST.length;
    while(low<=high)
    {
        mid = (low+high)/2;
        if(ST[mid]<key)
            low = mid;
        else if(ST[mid]>key)
            high = mid;
        else
            return mid;
    }
}
```
* 
分析：在查找成功的情况下和判定树的深度有关：比较次数至多 floor(log2(n))+1，平均：log2(n+1)-1

###2.分块查找、索引顺序查找
* 
思想：在顺序查找基础上建立一个索引表：对所有的元素分块，索引表就是对块的索引，记录块号起始位置和块中最大关键字，先在索引表中找块号，然后在该块中查找即可！

###3.[二叉排序、二叉平衡树](BST.md)

###4.B-树和B+树
####4.1 B-树
* 
思想：一颗m阶的B-树：每个节点至多有m课子树，除了根节点外每个节点至少m/2课子树。除叶子节点外的每个节点有关键字列表和指向子树的指针，关键字形成的范围是子树

###5.哈希：一个关键字对应一个存储位置
* 
冲突：关键字不同，哈希地址相同。冲突不可避免
* 
根据设定的哈希函数和处理冲突的方法将关键字映射到一个地址集上。
####5.1直接定址法
* 
直接根据关键字得到哈希地址
* 
冲突少，但是地址集与关键字集大小相同，使用较少。
####5.2数字分析法
* 
以关键字的某些位组成哈希地址
####5.3平方取中发
* 
取关键字平方后的中间几位为哈希地址
####5.4折叠法
* 
将关键字分割为位数相同的几部分，然后取叠加和作为哈希地址
####5.5除留余数法
* 
对某个小于哈希表表长的数p取余得到的为哈希地址：取余前可以折叠、平方等。p的选择至关重要
####5.6随机数法
* 
取关键字的随机函数值为哈希地址。
