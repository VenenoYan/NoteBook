##图：
### 基本概念：
```C
连通图：无向图中任意两个顶点都有路径
强连通图：有向图中任意两个顶点都存在路径
连通分量：无向图中的极大连通子图（可能有多个）
强连通分量：有向图中的极大连通子图（可能有多个）
生成树：极小连通子图，含有图中全部顶点，但只有足以构成一棵树的n-1条边，加一个边就有环（某个连通分量的）
    生成树分广度优先生成树和深度优先生成树两种
```
###1.实现：数组、邻接表、十字链表、邻接多重表
####1.1 数组实现
数组记录顶点，然后用邻接矩阵记录边的信息
####1.2 邻接表实现
```C
图的链式存储形式，对每个顶点都建立一个单链表。
表头节点：
    firstarc：指向第一个与该节点邻接的节点
    data: 必要的信息
内部节点：
    adjvex：顶点在图中的位置
    nextarc：下一个与该头节点邻接的顶点
    info：信息
然后这些单链表的表头节点按顺序存放，以便随即访问。
逆邻接表：即对每个对点建立一个以该顶点为头的弧的表
```
####1.3 十字链表实现
有向图的另一种链式存储方式
####1.4 邻接多重表实现
无向图的另一种链式存储方式

###2.遍历：对所有顶点扫描一次，故有一个辅助数组记录是否已访问
####2.1 BFS：广度优先搜索
类似于树的层次遍历

**思想：**
```
初始时，所有顶点未访问。BFS选择一个顶点开始访问，然后对该顶点进行层次遍历；
然后从这些邻接点出发继续访问他们的邻接点；
直至所以节点都被访问到。
```
**实现：**
```C
层次遍历需要queue
bool visited[num_of_vex]
void BFS_Traverse(Graph g,int v)
{
    for(v=0;v<num_of_vex;++v)   visited[v] = false;
    initqueue(q);
    for(v=0;v<num_of_vex;++v)   
    {
        if(visited[v] == false)
        {
            visited[v] = true;
            enqueue(q,v);
            while(!empty(q))
            {
                dequeue(q,u);
                for(w = firstadjvex(g,u);w>=0; w = nextadjvex(g,u,w))
                {
                    if(visited[w] == false)
                    {
                        visited[w] = true;
                        enqueue(w);
                    }
                }
            }
        }
    }   //以防还有未访问到的节点
}       

```
**总结：**
```C
数组实现：  O（n*n）    n代表顶点数
邻接表实现：O（n+e）    n代表顶点数，e代表边/弧数
```
####2.2 DFS：深度优先搜索
类似于树的先根遍历

**思想：**
```
初始时，所有顶点未访问。DFS选择一个顶点开始访问，然后从该顶点进行深度遍历直至结束或者遇到已访问的节点；
若此时还有未访问的节点，则以该节点开始继续；
直至所以节点都被访问到。
```
**实现：**
```C
bool visited[num_of_vex]
void DFS_Traverse(Graph g,int v)
{
    for(v=0;v<num_of_vex;++v)   visited[v] = false;
    for(v=0;v<num_of_vex;++v)   
    {
        if(visited[v] == false)
            DFS(g,v);
    }   //以防还有未访问到的节点
}       
void DFS(Graph g,int v)
{
    visited[v] = true;
    for(w = firstadjvex(g,v);w>=0;w = nextadjvex(g,v,w))
        if(visited[v] == false) 
            DFS(g,w);
}   //深度遍历以该顶点为起始的路径
```
**总结：**
```C
数组实现：  O（n*n）    n代表顶点数
邻接表实现：O（n+e）    n代表顶点数，e代表边/弧数
```
##3.图的经典算法：
###3.1 连通性问题与环
###3.2 最小生成树
###3.3 拓扑排序
###3.4 关键路径
###3.5 最短路径

两点最短路径：图的遍历算法即可