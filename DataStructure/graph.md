##图：
### 基本概念：
```C
完全图：n*(n-1)/2条边   n*(n-1)条弧
连通图：无向图中任意两个顶点都有路径
强连通图：有向图中任意两个顶点都存在路径
连通分量：无向图中的极大连通子图（可能有多个）
强连通分量：有向图中的极大连通子图（可能有多个）
生成树：极小连通子图，含有图中全部顶点，但只有足以构成一棵树的n-1条边，加一个边就有环（某个连通分量的）
    生成树分广度优先生成树和深度优先生成树两种
```
###1.实现：数组、邻接表、十字链表、邻接多重表
####1.1 数组实现
数组记录顶点，然后用邻接矩阵记录边的信息
####1.2 邻接表实现
```C
图的链式存储形式，对每个顶点都建立一个单链表。
表头节点：
    firstarc：指向第一个与该节点邻接的节点
    data: 必要的信息
内部节点：
    adjvex：顶点在图中的位置
    nextarc：下一个与该头节点邻接的顶点
    info：信息
然后这些单链表的表头节点按顺序存放，以便随即访问。
逆邻接表：即对每个对点建立一个以该顶点为头的弧的表
```
####1.3 十字链表实现
有向图的另一种链式存储方式
####1.4 邻接多重表实现
无向图的另一种链式存储方式

###2.遍历：对所有顶点扫描一次，故有一个辅助数组记录是否已访问
####2.1 BFS：广度优先搜索
类似于树的层次遍历

**思想：**
```
初始时，所有顶点未访问。
BFS选择一个顶点开始，然后以该顶点起始进行层次遍历；
然后从这些邻接点出发继续层次访问他们的邻接点；
直至所以节点都被访问到。
```
**实现：**
```C
层次遍历需要queue
bool visited[num_of_vex]
void BFS_Traverse(Graph g,int v)
{
    for(v=0;v<num_of_vex;++v)   visited[v] = false;
    initqueue(q);
    for(v=0;v<num_of_vex;++v)   
    {
        if(visited[v] == false)
        {
            visited[v] = true;
            enqueue(q,v);
            while(!empty(q))
            {
                dequeue(q,u);
                for(w = firstadjvex(g,u);w>=0; w = nextadjvex(g,u,w))
                {
                    if(visited[w] == false)
                    {
                        visited[w] = true;
                        enqueue(w);
                    }
                }
            }
        }
    }   //以防还有未访问到的节点
}       

```
**总结：**
```C
数组实现：  O（n*n）    n代表顶点数
邻接表实现：O（n+e）    n代表顶点数，e代表边/弧数
```
####2.2 DFS：深度优先搜索
类似于树的先根遍历

**思想：**
```
初始时，所有顶点未访问。
DFS选择一个顶点开始访问，然后从该顶点进行深度遍历直至访问所有的顶点或者遇到已访问的节点；
若此时还有未访问的节点，则以该节点开始继续；
直至所以节点都被访问到。
```
**实现：**
```C
bool visited[num_of_vex]
void DFS_Traverse(Graph g,int v)
{
    for(v=0;v<num_of_vex;++v)   visited[v] = false;
    for(v=0;v<num_of_vex;++v)   
    {
        if(visited[v] == false)
            DFS(g,v);
    }   //以防还有未访问到的节点
}       
void DFS(Graph g,int v)
{
    visited[v] = true;
    for(w = firstadjvex(g,v);w>=0;w = nextadjvex(g,v,w))
        if(visited[v] == false) 
            DFS(g,w);
}   //深度遍历以该顶点为起始的路径
```
**总结：**
```C
数组实现：  O（n*n）    n代表顶点数
邻接表实现：O（n+e）    n代表顶点数，e代表边/弧数
```
###2.3 搜索树
即根据上述算法的遍历过程生成的树，
##3.图的经典算法：
###3.1 连通性问题
连通图仅需从一个节点出发通过DFS或者BFS就可以访问所有的节点；而非连通图则需要从多个节点出发进行搜索
###3.2 最小生成树
MST性质：假设N={V,{E}}是一个连通网，U是顶点集V的非空子集。若u∈U，v∈V-U,且（u,v）是一条具有最小权值的边那么最小生成树一定包含该边。<br>
两个算法：普里姆(prim)和克鲁斯卡尔(kruskal)，均利用上述性质
####3.2.1 普里姆prim
####3.2.1.1 prim思想
假设N={V,{E}}是一个连通网：TE是最小生成树中边的集合，U是V的一个子集。<br>
初始状态：TE = {},U={u0},u0∈V,
<br>
重复下述操作：<br>
**对于所有的u∈U，v∈V-U,且（u,v）∈E，找到(u,v)是权值最小的边，边加入到TE 中，顶点v加入到U中。**
直至U=V为止。<br>
此时，T = {U,{TE}}即最小生成树
####3.2.1.2 prim实现
```C
void prim_code(MGraph G,VertexType u)
{
    vertex U,V;
    arc TE;
    U.insert(u);
    while(U!=V)
    {
        v = find_closest(G,U,V);
        U.insert(v);
        TE.insert(u,v)
    }
}
vertex find_closest(MGraph,vertex []U,vertex []V)   //返回最小边的另一个顶点
```
####3.2.1.3 prim分析
时间复杂度为：O（N*N），与边数无关。
<br>
所以适合求稠密图的最小生成树
####3.2.2 克鲁斯卡尔kruskal
####3.2.1.1 kruskal思想
假设N={V,{E}}是一个连通网<br>
最小生成树的初始状态：T = {V，{}},U=V,边集为空，图中每个顶点自成一个连通分量；
<br>
重复下述操作：**在所有边中，选择权值最小而且两个顶点在不同连通分量中的边，加入到T中，否则选择下一个权值最小的边**<br>
直至所有顶点都在一个连通分量中为止。<br>
此时，T = {U,{TE}}即最小生成树
####3.2.1.2 kruskal实现

####3.2.1.3 kruskal分析
时间复杂度：O（e*loge）， 与顶点数无关<br>
适合稀疏图
###3.3 拓扑排序与环：事件直接的先后关系
DGA：有向无环图
<br>
**环是否存在：**<br>
####3.3.1 无向图：
**法一**：深度遍历时只要不遇到回边即可，需要额外记录边的信息。边数<=顶点数-1；<br>
**法二**：首先把图中所有度小于等于1的顶点删除，同时删除所有相连的边并修改连接顶点的度，把所有度变成1的顶点加入队列中；对队列中每个顶点重复上一操作，如果最后还有未删除顶点则有环，否则没有<br>
####3.3.2 有向图：拓扑排序
####3.3.2.1 拓扑排序思想
在有向图中选一个没有前驱的顶点输出；<br>
从图中删除该顶点和所有以他为尾的弧；<br>
重复上述两步，如果无节点说明以结束；否则说明有环；
####3.3.2.1 拓扑排序实现
保存顶点的入度
```C
求入度；
while(无顶点||无入度为0的顶点)
{
    找入度为0的顶点；
    删除该顶点和所有与其相关的弧；
}
判断是无顶点还是无入度为0的顶点，前者说明排序完成，后者说明有环；
```
####3.3.2.1 拓扑排序分析
时间复杂度：O（n+e）<br>
**顶点可以代表活动，弧代表先后关系========》作选择时先后关系**
###3.4 关键路径：
带权值的有向无环图：顶点代表事件，弧代表活动，权值代表花费；
####3.3.1 思想：开始到结束的路径
关键路径上的活动都是关键活动<br>
活动最早开始时间E(i)和最晚开始时间L(i)，如果L(i)==E(i)，则活动i是关键活动，L(i)-E(i)代表活动i的可休息时间。
####3.4.2.1 关键路径分析
时间复杂度：O（n+e）<br>
**顶点可以代表某件事，弧代表完成事件的具体活动，权值代表时间或者其他花费====》得到工程总时间和关键活动**
###3.5 最短路径

两点最短路径：图的遍历算法即可