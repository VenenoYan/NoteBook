##图：
### 基本概念：
```C
完全图：n*(n-1)/2条边   n*(n-1)条弧
连通图：无向图中任意两个顶点都有路径
强连通图：有向图中任意两个顶点都存在路径
连通分量：无向图中的极大连通子图（可能有多个）
强连通分量：有向图中的极大连通子图（可能有多个）
生成树：极小连通子图，含有图中全部顶点，但只有足以构成一棵树的n-1条边，加一个边就有环（某个连通分量的）
    生成树分广度优先生成树和深度优先生成树两种
```
###1.实现：数组、邻接表、十字链表、邻接多重表
####1.1 数组实现
数组记录顶点，然后用邻接矩阵记录边的信息
####1.2 邻接表实现
```C
图的链式存储形式，对每个顶点都建立一个单链表。
表头节点：
    firstarc：指向第一个与该节点邻接的节点
    data: 必要的信息
内部节点：
    adjvex：顶点在图中的位置
    nextarc：下一个与该头节点邻接的顶点
    info：信息
然后这些单链表的表头节点按顺序存放，以便随即访问。
逆邻接表：即对每个对点建立一个以该顶点为头的弧的表
```
####1.3 十字链表实现
有向图的另一种链式存储方式
####1.4 邻接多重表实现
无向图的另一种链式存储方式

###2.遍历：对所有顶点扫描一次，故有一个辅助数组记录是否已访问
####2.1 BFS：广度优先搜索
类似于树的层次遍历

**思想：**
```
初始时，所有顶点未访问。
BFS选择一个顶点开始，然后以该顶点起始进行层次遍历；
然后从这些邻接点出发继续层次访问他们的邻接点；
直至所以节点都被访问到。
```
**实现：**
```C
层次遍历需要queue
bool visited[num_of_vex]
void BFS_Traverse(Graph g,int v)
{
    for(v=0;v<num_of_vex;++v)   visited[v] = false;
    initqueue(q);
    for(v=0;v<num_of_vex;++v)   
    {
        if(visited[v] == false)
        {
            visited[v] = true;
            enqueue(q,v);
            while(!empty(q))
            {
                dequeue(q,u);
                for(w = firstadjvex(g,u);w>=0; w = nextadjvex(g,u,w))
                {
                    if(visited[w] == false)
                    {
                        visited[w] = true;
                        enqueue(w);
                    }
                }
            }
        }
    }   //以防还有未访问到的节点
}       

```
**总结：**
```C
数组实现：  O（n*n）    n代表顶点数
邻接表实现：O（n+e）    n代表顶点数，e代表边/弧数
```
####2.2 DFS：深度优先搜索
类似于树的先根遍历

**思想：**
```
初始时，所有顶点未访问。
DFS选择一个顶点开始访问，然后从该顶点进行深度遍历直至访问所有的顶点或者遇到已访问的节点；
若此时还有未访问的节点，则以该节点开始继续；
直至所以节点都被访问到。
```
**实现：**
```C
bool visited[num_of_vex]
void DFS_Traverse(Graph g,int v)
{
    for(v=0;v<num_of_vex;++v)   visited[v] = false;
    for(v=0;v<num_of_vex;++v)   
    {
        if(visited[v] == false)
            DFS(g,v);
    }   //以防还有未访问到的节点
}       
void DFS(Graph g,int v)
{
    visited[v] = true;
    for(w = firstadjvex(g,v);w>=0;w = nextadjvex(g,v,w))
        if(visited[v] == false) 
            DFS(g,w);
}   //深度遍历以该顶点为起始的路径
```
**总结：**
```C
数组实现：  O（n*n）    n代表顶点数
邻接表实现：O（n+e）    n代表顶点数，e代表边/弧数
```
###2.3 搜索树
即根据上述算法的遍历过程生成的树，
##3.图的经典算法：
###3.1 连通性问题
连通图仅需从一个节点出发通过DFS或者BFS就可以访问所有的节点；而非连通图则需要从多个节点出发进行搜索
###3.2 最小生成树
MST性质：假设N={V,{E}}是一个连通网，U是顶点集V的非空子集。若u∈U，v∈V-U,且（u,v）是一条具有最小权值的边那么最小生成树一定包含该边。<br>
两个算法：普里姆(prim)和克鲁斯卡尔(kruskal)，均利用上述性质
####3.2.1 普里姆prim
####3.2.1.1 prim思想
假设N={V,{E}}是一个连通网：TE是最小生成树中边的集合，U是V的一个子集。<br>
初始状态：TE = {},U={u0},u0∈V,
<br>
重复下述操作：<br>
**对于所有的u∈U，v∈V-U,且（u,v）∈E，找到(u,v)是权值最小的边，边加入到TE 中，顶点v加入到U中。**
直至U=V为止。<br>
此时，T = {U,{TE}}即最小生成树
####3.2.1.2 prim实现
```C
void prim_code(MGraph G,VertexType u)
{
    vertex U,V;
    arc TE;
    U.insert(u);
    while(U!=V)
    {
        v = find_closest(G,U,V);
        U.insert(v);
        TE.insert(u,v)
    }
}
vertex find_closest(MGraph,vertex []U,vertex []V)   //返回最小边的另一个顶点
```
####3.2.1.3 prim分析
时间复杂度为：O（N*N），与边数无关。
<br>
所以适合求稠密图的最小生成树
####3.2.2 克鲁斯卡尔kruskal
####3.2.1.1 kruskal思想
假设N={V,{E}}是一个连通网<br>
最小生成树的初始状态：T = {V，{}},U=V,边集为空，图中每个顶点自成一个连通分量；
<br>
重复下述操作：**在所有边中，选择权值最小而且两个顶点在不同连通分量中的边，加入到T中，否则选择下一个权值最小的边**<br>
直至所有顶点都在一个连通分量中为止。<br>
此时，T = {U,{TE}}即最小生成树
####3.2.1.2 kruskal实现

####3.2.1.3 kruskal分析
时间复杂度：O（e*loge）， 与顶点数<br>
适合稀疏图
###3.3 拓扑排序与环
###3.4 关键路径
###3.5 最短路径

两点最短路径：图的遍历算法即可