1. 
全局变量可以定义在被多个.c文件包含的头文件中吗？<br>
答：如果是static/const是可以的，因为每一个源文件会自动编译为**自己的局部全局变量**；但是如果是普通的，那么会造成**重复定义**
1. 
类中public与private函数可以同名吗？<br>
答：不能，
1. 
父指针指向孩子对象，调用普通函数与虚函数的区别？<br>
答：普通函数调用父亲自己的，虚函数才会调用孩子的。======》看虚函数表就懂了
* 
模板Template用到class、typename这两个关键字，那么他们相同吗？<br>
答：在C++刚开始引入模板时，class表示类，所以直接被用来表示引用的类型```template<class T>```；但是为避免class在两个地方使用造成误解，所以引入typename关键字来表示后面的符号为类型。所以class、template的作用是相同的。```template<class T>```与```template<typename T>```等价。
* 
auto<br>
答：自动类型推断以及返回值类型占位。**但是**必须初始化，不能用于函数参数。
* extern C<br>
由于C++在编译的时候会对函数名进行修饰(其实就是函数名加参数以及一些其他的东西生成符号)，但是C语言只会编译函数名，所以如果按照C++的编译那么C就不起作用了，所以extern C的作用就是告诉编译器下面的代码按照C语言来编译
* 
多态：
    * 
运行时多态：依托```虚函数```实现；针对含有虚函数的类可能被重写，父指针指向子类的情况下调用虚函数才会产生，编译器会生成虚函数表(Vtable)，运行期间调用虚函数时查该表从而确定函数的真正实现；
        * 优点：面向对象的特性；解决统一继承体系下异质类集合；
        * 缺点：运行时确定提高程序开销（多一次地址转换）；编译器无法优化；
    * 
编译时多态：在编译的时候由于```重载包括操作符重载或者模板```，不同的实例或者参数导致调用不同的函数；
        * 优点：解决泛型编程的难题；编译器完成提高效率；
        * 缺点：无法分离编译（模板）；可读性低；

* 
return 和 exit的不同
    * 
exit是系统调用，是不会退栈的，表示一个进程的结束！！它会将控制权交给系统（多线程返回给父进程），，删除进程使用的内存空间，并将应用程序的一个状态返回给OS，这个状态标识了应用程序的一些运行信息，
    * return不是系统调用是C语言的函数，它会退栈将执行控制权交给调用函数，引发退栈操作，子进程退栈的操作可能会修改父进程的栈，所有return不行。
    * main函数中调用return，会隐式调用exit：非主函数中调用return和exit效果很明显，但是在main函数中调用return和exit的现象就很模糊，多数情况下现象都是一致的。
    * fork和vfork中区别大，因为vfork是共享内存，所以可以exit，但是不能是return，否则子结束因为退栈把父的也改变了。
* 
auto、static、register、extern、const和volitate
    * auto：自动变量，一般auto省略；C++11用于范围for循环
    * static：局部（延迟初始化&第一次&仅一次）、全局（本文件可见）、函数（本文件可见）、类中（成员、函数===类的，不属于任何实例）
    * register：直接写入寄存器中
    * extern：声明变量在其他文件中
    * const：只读常数。普通、引用、指针(6种)、函数参数和返回值、修饰类成员函数
    * volitate：该值可能有意想不到的改变，需要从内存读。因为它是你自己不动也可能改变的东西。
        * 并行设备的硬件寄存器（如：状态寄存器）
        * 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
        * 多线程应用中被几个任务共享的变量
        * 一个参数既可以是const还可以是volatile吗？解释为什么。
            * 可以。修改状态寄存器 
        * 一个指针可以是volatile 吗？解释为什么。
            * 可以。指针可变
* 
const、static
    * 
static关键字：面向过程和面向对象
        * 
函数体内static变量的作用范围为函数体。不同于auto变量。该变量的内存只被分配一次。因此其值在下次调用时仍维持上次的值。
        * 
在模块内的static全局变量可以被模块内的所有函数访问。但不能被模块外的其他函数访问。
        * 
在模块内的static函数只可被这一模块内的其它函数调用。这个函数的使用范围被限制在声明它的模块内。
        * 
在类中的static成员变量属于整个类所有，对类的所有对象只有一份复制。
        * 
在类中的static成员函数属于整个类所有，这个函数不接受this指针，因而只能访问类的static成员变量。
    * 
const关键字：
        * 
欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化。因为以后就没有机会再改变它了。
        * 
对指针来说，可以指定指针的本身为const，也可以指定指针所指向的数为const。或二者同时为const。
        * 
在一个函数的声明中，const可以修饰形参，表明它是一个输入参数。在函数内不能改变其值。
        * 
对于类的成员函数，若指定其为const类型。则表明其是一个常量函数。不能修改类的成员变量。
        * 
对于类的成员函数，有时候必须指定其返回值为const类型。以使得其返回值不为“左值”。 
1. 
强制类型转换
    1. c风格强制转换
    ```
    int a=1;
    char b=(char)a;```<br>
     这种转换适用于面向过程的没有类的概念的c语言的转换，然而这样的转换符也能不分青红皂白的应用于类和类的指针，没有安全检查。转换后源的格式依然不变
    2. const_cast　  ```const_cast<type_id> (expression) ```<br>
　　用于修改类型的const或volatile属性，一般用于强制消除对象的常量性，c中不提供消除这const的机制<br>

    3. static_cast ```static_cast<type_id> (expression)```<br>
　　该转换和c风格的转换很类似，没有运行时类型检查，所以无法保证转换的安全性。主要有以下几种用法：<br>
　　（1）用于基本数据类型，或者non_const到const（反过来必须用const_cast)<br>
　　（2）把空指针转换为目标类型的指针<br>
　　（3）将任何类型的表达式转换为void类型<br>
　　（4）可以将子类类型的指针转换为父类类型的指针（这种转换的安全性需要开发人员来保证）<br>
    4. dynamic_cast```dynamic_cast<type*>(expression)```<br>
　　他只用于对象和引用，主要用于执行安全的向下转型，他可以将指向子类的父类指针转换为子类指针，但是要求父类有虚函数，如果转换为指针类型失败则返回NULL，如果是引用类型转换失败则跑出bad_cast的异常

    5. reinpreter_cast

　　用法：reinpreter_cast<type_id> (expression)

　　type_id可以是指针，引用，算术类型，函数指针或者成员指针，这个操作符可以在非相关的类型之间转换，操作只是简单的从一个指针到别的指针的值得二进制拷贝，在类型之间指向的内容不作任何类型的检查和转换。

note：关于static_cast 和 dynamic_cast的区别：

a. static在转换时不进行安全性检查，完全需要开发者自己考虑, dynamic 在转换的时候会进行安全性检查，如果是指针类型的转换失败返回NULL，如果是引用类型的转换失败，则跑出bad_cast 异常。

b. static主要是用于值类型之间的转换，而dynamic只能用于对象的指针和引用的cast，dynamic是向下的转换，而且要求父类有虚函数，否则会编译出错。

[返回目录](README.md)