1. 
全局变量可以定义在被多个.c文件包含的头文件中吗？<br>
答：如果是static/const是可以的，因为每一个源文件会自动编译为**自己的局部全局变量**；但是如果是普通的，那么会造成**重复定义**
1. 
类中public与private函数可以同名吗？<br>
答：不能，
1. 
父指针指向孩子对象，调用普通函数与虚函数的区别？<br>
答：普通函数调用父亲自己的，虚函数才会调用孩子的。======》看虚函数表就懂了
* 
模板Template用到class、typename这两个关键字，那么他们相同吗？<br>
答：在C++刚开始引入模板时，class表示类，所以直接被用来表示引用的类型```template<class T>```；但是为避免class在两个地方使用造成误解，所以引入typename关键字来表示后面的符号为类型。所以class、template的作用是相同的。```template<class T>```与```template<typename T>```等价。
* 
auto<br>
答：自动类型推断以及返回值类型占位。**但是**必须初始化，不能用于函数参数。
* extern C<br>
由于C++在编译的时候会对函数名进行修饰(其实就是函数名加参数以及一些其他的东西生成符号)，但是C语言只会编译函数名，所以如果按照C++的编译那么C就不起作用了，所以extern C的作用就是告诉编译器下面的代码按照C语言来编译
* 
多态：
    * 
运行时多态：依托```虚函数```实现；针对含有虚函数的类可能被重写，父指针指向子类的情况下调用虚函数才会产生，编译器会生成虚函数表(Vtable)，运行期间调用虚函数时查该表从而确定函数的真正实现；
        * 优点：面向对象的特性；解决统一继承体系下异质类集合；
        * 缺点：运行时确定提高程序开销（多一次地址转换）；编译器无法优化；
    * 
编译时多态：在编译的时候由于```重载包括操作符重载或者模板```，不同的实例或者参数导致调用不同的函数；
        * 优点：解决泛型编程的难题；编译器完成提高效率；
        * 缺点：无法分离编译（模板）；可读性低；

* 
return 和 exit的不同
    * 
exit是系统调用，是不会退栈的，表示一个进程的结束！！它会将控制权交给系统（多线程返回给父进程），，删除进程使用的内存空间，并将应用程序的一个状态返回给OS，这个状态标识了应用程序的一些运行信息，
    * return不是系统调用是C语言的函数，它会退栈将执行控制权交给调用函数，引发退栈操作，子进程退栈的操作可能会修改父进程的栈，所有return不行。
    * main函数中调用return，会隐式调用exit：非主函数中调用return和exit效果很明显，但是在main函数中调用return和exit的现象就很模糊，多数情况下现象都是一致的。
    * fork和vfork中区别大，因为vfork是共享内存，所以可以exit，但是不能是return，否则子结束因为退栈把父的也改变了。
* 
auto、static、register、extern、const和volitate
    * auto：自动变量，一般auto省略
    * static：局部（延迟初始化&第一次&仅一次）、全局（本文件可见）、函数（本文件可见）、类中（成员、函数===类的，不属于任何实例）
    * register：直接写入寄存器中
    * extern：声明变量在其他文件中
    * const：只读常数。普通、引用、指针(6中)
    * volitate：该值可能有意想不到的改变，需要从内存读。因为它是你自己不动也可能改变的东西。
        * 一个参数既可以是const还可以是volatile吗？解释为什么。
        * 一个指针可以是volatile 吗？解释为什么。



[返回目录](README.md)