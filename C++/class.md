```C
#include <stdlib.h>
#include <iostream>
using namespace std;

struct CLS
{
    int m_i;
    CLS()=default;  //当你定义了构造函数，初始化时必须按照此要求来。加上‘=default’可以“使用”编译器的默认构造函数
    explicit CLS(char c); //仅用于单个参数的构造函数：不能发生相应的隐式类型转换：CLS t = CLS(18);CLS t(18)错
    CLS( int i ) : m_i(i){}
    CLS()
    {
        CLS(0);
    }
};
int main()
{
    CLS obj;
    cout << obj.m_i << endl;

    system("PAUSE");
    return 0;
}```

打印结果是不定的:不一定为0 
<br>代码奇怪的地方在于构造函数中调用了自己的另一个构造函数<br>
我们知道，当定义一个对象时，会按顺序做2件事情：<br>
    1）分配好内存（非静态数据成员是未初始化的）<br>
    2）调用构造函数（构造函数的本意就是初始化非静态数据成员）<br>
显然上面代码中，CLS obj；这里已经为obj分配了内存，然后调用默认构造函数，但是默认构造函数还未执行完，却调用了另一个构造函数，这样相当于产生了一个匿名的临时CLS对象，它调用CLS(int)构造函数，将这个匿名临时对象自己的数据成员m_i初始化为0；但是obj的数据成员并没有得到初始化。于是obj的m_i是未初始化的，因此其值也是不确定的<br>
从这里，我们归纳如下：<br>
1）在c++里，由于构造函数允许有默认参数，使得这种构造函数调用构造函数来重用代码的需求大为减少<br>
2）如果仅仅为了一个构造函数重用另一个构造函数的代码，那么完全可以把构造函数中的公共部分抽取出来定义一个成员函数(推荐为private),然后在每个需要这个代码的构造函数中调用该函数即可<br>
3）偶尔我们还是希望在类的构造函数里调用另一个构造函数，可以按下面方式做：<br>
在构造函数里调用另一个构造函数的关键是让第二个构造函数在第一次分配好的内存上执行，而不是分配新的内存，这个可以用标准库的**placement new技术**做到(或者定义一个private函数实现公共功能)：
```C
struct CLS
{
    int m_i;
    CLS( int i ) : m_i(i){}
    CLS()
    {
        new (this)CLS(0);
    }
};```
所以尽量避免在构造函数中调用构造函数，不管是构造函数自身还是重载过的构造函数