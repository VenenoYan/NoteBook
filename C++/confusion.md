
## 混淆点：

**1. 
暂停：**
```C
system("pause")             #include <unistd.h>
Sleep()
getchar()```

**2. 函数名/函数地址/函数指针**
```C
每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。
函数名相当于一个指向其函数入口指针常量。
#include
　　int max(int x,int y){ return(x>y?x:y); }
　　void main()
　　{
    　　int (*ptr)(int, int);       /* 声明一个函数指针 */
    　　int a,b,c;
    　　ptr=max;                    /* 将max函数的首地址赋给指针ptr,max不带括号和参数，max代表函数的首地址 */
    　　scanf("%d,%d",&a,&b);
    　　c=(*ptr)(a,b);
    　　printf("a=%d,b=%d,max=%d",a,b,c);
　　}
　  实际上ptr和max都指向同一个入口地址，不同就是ptr是一个指针变量，不像函数名称那样是死的，它可以指向任何函数
注意，指向函数的指针变量没有++和--运算```


#### **3. static**

<br>
    [static](static.md)变量于全局数据区。第一次实例化或使用后就一直存在。
   1. 对局部static变量的每一次访问，都是访问全局数据区。即获有“全局变量”性质，每一次改变都是全局数据区的改变。
   1. 全局static变量和类中的static局部变量都是针对当前文件或者类来说的。引用当前文件或者实例化类时，可以有同名而不冲突。因为针对当前文件、类
   2. 类中的static函数只能访问static成员，不能访问其他的成员。因为类中的static成员是类有的，而不是实例特有。


### 4.auto
auto关键字可以从表达式中推导出变量的类型，这样就大大简化了编程人员的工作。而且auto是在编译时对变量进行了类型推导，所以不会对程序的效率造成影响，另外auto也不会对编译速度造成太大影响，因为编译时本身也要右侧推导后判断是否与左侧匹配。
```C++
vector<int> tt(a,a+4);
for(auto it=tt.begin();it!=tt.end();++tt)
    ...
```
### 5.implicit/explicit
首先explicit这个关键字只能用在类内部的构造函数声明上，而不能用在类外部的函数定义上，它的作用是不能进行隐式转换。
### 7.mutable