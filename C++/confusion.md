
## 混淆点：

**1. 
暂停：**
```C
system("pause")             #include <unistd.h>
Sleep()
getchar()```

**2. 函数名/函数地址/函数指针**
```C
每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。
函数名相当于一个指向其函数入口指针常量。
#include
　　int max(int x,int y){ return(x>y?x:y); }
　　void main()
　　{
    　　int (*ptr)(int, int);       /* 声明一个函数指针 */
    　　int a,b,c;
    　　ptr=max;                    /* 将max函数的首地址赋给指针ptr,max不带括号和参数，max代表函数的首地址 */
    　　scanf("%d,%d",&a,&b);
    　　c=(*ptr)(a,b);
    　　printf("a=%d,b=%d,max=%d",a,b,c);
　　}
　  实际上ptr和max都指向同一个入口地址，不同就是ptr是一个指针变量，不像函数名称那样是死的，它可以指向任何函数
注意，指向函数的指针变量没有++和--运算```


#### **3. static**

<br>static被引入以告知编译器，将变量存储在程序的全局静态存储区而非栈上空间。

[static](static.md)变量于全局数据区。第一次实例化或使用后就一直存在。
   1. 对局部static变量的每一次访问，都是访问全局数据区。即获有“全局变量”性质，每一次改变都是全局数据区的改变。
   1. 全局static变量和类中的static局部变量都是针对当前文件或者类来说的。引用当前文件或者实例化类时，可以有同名而不冲突。**因为针对当前文件、类，对其他文件或者类不可见**
   2. 类中的static函数只能访问static成员，不能访问其他的成员。因为类中的static成员是类有的，而不是实例特有。


### **4.auto**
auto关键字可以从表达式中推导出变量的类型，这样就大大简化了编程人员的工作。而且auto是在编译时对变量进行了类型推导，所以不会对程序的效率造成影响，另外auto也不会对编译速度造成太大影响，因为编译时本身也要右侧推导后判断是否与左侧匹配。
```C++
vector<int> tt(a,a+4);
for(auto it=tt.begin();it!=tt.end();++tt)
    ...
```
### **5.implicit/explicit**
首先explicit这个关键字只能用在类内部的**单参数构造函数声明**上，而不能用在类外部的函数定义上，它的作用是不能进行隐式转换。即显示的指明用那个构造函数。implicit是默认的，可以自动使用最“接近的”构造函数，但是当构造函数参数超过两个后自动关闭implicit.
### **7.mutable/const**
const 推出的初始目的，正是为了取代预编译指令，消除它的缺点，同时继承它的优点。
* 
首先，以const 修饰的常量值，具有不可变性，这是它能取代预定义语句的基础。
* 
第二 可以很方便地进行参数的调整和修改。
* 
第三，C++的编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高，同时，这也是它取代预定义语句的重要基础。
* 
同样，必须初始化（特别是类中，必须在初始化列表解决）
* 
修饰函数时，则不可以修改调用的对象

mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。
### **8.左值/右值**

左值：可以取地址、有名字-----》即可以在内存中读写

右值：不可以取地址

左值引用：正常的C++98中的

右值引用：T && 右值没有名字，相当于引用其值