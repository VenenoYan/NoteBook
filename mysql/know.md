####1. 复制相关
众所周知，MySQL**只支持一对多的主从复制**，而不支持多主（multi-master）复制。 
* 
在有多个slave参与的半同步复制中，master并不一定需要等待全部slave返回
* 
MySQL使用多主复制时，需要修改自增长变量参数,所以有人认为不支持。
* 
一般情况下，异步复制的性能比半同步复制好，但后者相对更为安全<br>
**基于行的复制** MySQL 5.1 中，在复制方面的改进就是引进了新的复制技术.基于行的复制。
简言之，这种新技术就是关注表中发生变化的记录，而非以前的照抄** binlog 模式**。<br>
从 MySQL 5.1.12 开始，可以用以下三种模式来实现：
* 
基于SQL语句的复制(statement-based replication, SBR)，
* 
基于行的复制(row-based replication, RBR)，
* 
混合模式复制(mixed-based replication, MBR)。<br>
相应地，binlog的格式也有三种：STATEMENT，ROW，MIXED。 MBR 模式中，SBR 模式是默认的。<br>
**Mysql复制分成三步：** 
* 
master将改变记录到二进制日志(binary log)中（这些记录叫做二进制日志事件，binary log events）； 
* 
slave将master的binary log events拷贝到它的中继日志(relay log)； 
* 
slave重做中继日志中的事件，将改变反映它自己的数据。

####3. 事务：
是一系列的数据库操作，是数据库应用的基本逻辑单位。性质：
* 
原子性。即不可分割性，事务要么全部被执行，要么就全部不被执行。
* 
一致性。事务的执行使得数据库从一种正确状态转换成另一种正确状态
* 
隔离性。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，
* 
持久性。事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。

####4. 三范式：
* 
1NF:每个属性是不可分的。 
* 
2NF:若关系R是１NF,且每个非主属性都**完全函数依赖**于主键。例SLC(SID#, CourceID#, SNAME,Grade),则不是2NF;     ===》也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。
* 
3NF:若R是2NF，且它的任何非键属性都不传递依赖于任何候选键（即非主键）。<br>
===》即每一列数据都和主键直接相关，而不能间接相关。<br>
**例子**
* 
不符合第一范式的例子(关系数据库中create不出这样的表)：
```表:字段1, 字段2(字段2.1, 字段2.2), 字段3 ......```
* 
不符合第二范式的例子:```表:学号, 姓名, 年龄, 课程名称, 成绩, 学分;``` ==》说明了两个事务:学生信息, 课程信息; <br>
**[存在问题](http://www.jb51.net/article/70867.htm):**
* 
数据冗余，每条记录都含有相同信息；
* 
删除异常：删除所有学生成绩，就把课程信息全删除了；
* 
插入异常：学生未选课，无法记录进数据库；
* 
更新异常：调整课程学分，所有行都调整。 
####5.  完整性约束：
* 
实体完整性：是指关系(所谓的关系就是表)的主码即主键不能取空值
* 
参照完整性：是指参照关系中每个元素的外码要么为空(NULL)，要么等于被参照关系中某个元素的主码；
* 
用户定义完整性：指对关系中每个属性的取值有一个限制(或称为约束)的具体定义。比如 性别属性只能取”男“或”女“  ；

####6. 索引作用
* 
作用：为每张表相当于添加一个目录，检索更快；索引是建立在数据库表中的某些列的上面。
* 
优点：
    * 
第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
    * 
第二，可以大大加快 数据的**检索速度**，这也是创建索引的最主要的原因。
    * 
第三，可以**加速表和表之间的连接**，特别是在实现数据的参考完整性方面特别有意义。
    * 
第四，在使用**分组和排序 子句**进行数据检索时，同样可以显著减少查询中分组和排序的时间。
    * 
第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 
* 
缺点：
    * 
第一，创建索引和维护索引要**耗费时间**，这种时间随着数据 量的增加而增加。
    * 
第二，索引需要占**物理空间**，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。
    * 
第三，当对表中的数据进行增加、删除和修改的时候，**索引也要动态的维护**，这样就降低了数据的维护速度。 
* 
那些适合建索引：
    * 
在作为**主键的列**上，强制该列的唯一性和组织表中数据的排列结构；
    * 
在**经常用在连接**的列上，这 些列主要是一些外键，可以加快连接的速度；
    * 
在经常需要根**据范围进行搜索**的列上创建索引，因为索引已经排序，其指定的范围是连续的；
    * 
在经常**需要排序**的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；
    * 
在经常使用**在WHERE子句中的列**上面创建索引，加快条件的判断速度。 
* 
那些不适合：
    * 
对于那些在查询**中很少使用**或者参考的列不应该创建索引。
    * 
对于那 些只**有很少数据值的列**也不应该增加索引。
    * 
对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。 
    * 
**总的来说**：当修改性能远远大于检索性能时，不应该创建索 引。

####7. 内联接,外联接区别？
* 
内连接（inner join）是保证两个表中所有的行都要满足连接条件：典型的联接运算，使用像 =  或 < > 之类的比较运算符；
* 
在外连接中，某些不满条件的列也会显示出来，也就是说，只限制其中一个表的行，而不限制另一个表的行。分左连接、右连接、全连接三种：    
    * 
左连接（left join）：结果集包括  LEFT OUTER子句中指定**的左表的所有行**，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值。
    * 
右连接（right join）：与左连接相似，只是如果右表对应的左表没有，则填充空，**右表的所有行**
    * 
全连接（full join ）：返**回左表和右表中的所有行**。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。 
    * 
交叉连接（cross join） ：将两个表的所有行进行组合，连接后的行数为两个表的笛卡尔积数。
<br>
**例子**

| A表： | ID | Name | B表 | ID| Age | Pid |
| -- | -- | -- | -- | -- | -- | -- |
|  | 1 | 张三 |  | 1 | 52 | 1 |
|  | 2 | 李四 |  | 2 | 35 | 2 |
|  | 3 | 王武 |  | 3 | 64 | 4 |
A表ID与B表的Pid存在相关关系：
```SQL
1） 内连接 ：两张表完全匹配的几个数据集
      select   a.*,b.*   from   a   inner   join   b     on   a.id=b.parent_id      
      结果是    
      1   张3     1     23     1  
      2   李四    2     34     2  

2）左连接 ：左表的所有和右表的匹配，没有在右表匹配到的天NULL
      select   a.*,b.*   from   a   left   join   b     on   a.id=b.parent_id      
      结果是    
      1   张3     1     23     1  
      2   李四    2     34     2  
      3   王武    null  

3） 右连接 ：左表和右表所有匹配，左表没有的填NULL
      select   a.*,b.*   from   a   right   join   b     on   a.id=b.parent_id      
      结果是    
      1   张3    1     23     1  
      2   李四   2     34     2  
      null       3     34     4  

4） 完全连接 ：两张表的合集，对方没有的填NULL
      select   a.*,b.*   from   a   full   join   b     on   a.id=b.parent_id  
      结果是    
      1   张3     1     23     1  
      2   李四    2     34     2  
      null        3     34     4  
      3   王武    null
```


####8. 锁：共享锁、互斥锁
两段锁协议：阶段１：加锁阶段 阶段２：解锁阶段

####9. 死锁及处理：事务循环等待数据锁，则会死锁。

死锁处理：预防死锁协议，死锁恢复机制

####10. 视图

####11. 

####12. 

####13. 

####14. 

####15. 
