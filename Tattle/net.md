**网络字节序，大小端**

大小端：主要是多字节值的哪一端存放在起始地址处（即低地址处）。
* 大端 ：高字节在低地址处，直观。
* 小端 ：低字节在低地址处
* 如示例：
 ![](../b2de9c82d158ccbfba5e4c721ed8bc3eb035419c.jpg)

TCP/UDP/IP网络协议规定：接收的第一个字节是高字节，会放到低地址处。<br>所以要求发送方第一个字节应该**发送高字节。由从低地址处取**，所以一般是大端。
网络传输的都是**字节流**

#### OSI七层：TCP、IP/模型
| OSI | ： | TCP/IP |
| -- | -- | -- |
| 应用层： |  
| 表示层：通讯系统通信 |  | 应用层 |
| 会话层：进程间通信 |  
| 传输层：报文段TCP、用户数据报UDP；主机进程点对点通信 |  | 传输层 |
| 网络层：数据报传递 |  | 网络层 |
| 数据链路层：数据帧传递 |  
| 物理层：比特位传输 |  | 网际接口层 |

**基础知识：什么是TCP/IP、UDP、Socket**

  TCP/IP(Transmission Control Protocol/Internet Protocol)<br>
  UDP(User Data Protocol)<br>
  网络模型图：
  ![](../1.jpg)

那么Socket在那呢？

  ![](../12.jpg)
     <br>  Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。<br>
      ![](../32.jpg)
 
**HTTP的过程和原理，以连接www.baidu.com为例**
  * 
  首先需要建立socket连接(IP和port)，所以会先做DNS解析，由url网址得到IP地址：
      * 
本地向本地域名服务器查询，如果没有，本地域名服务器向上层域名服务器请求，直至根服务器。 注：本机在配置网络的时候会指定本地DNS服务器，而且一般浏览器也有自己的缓存
      * 
得到IP地址，port是指定好的。
  * 
建立Sockect连接
  * 
然后发送web请求给指定的web服务器：GET、POST
  * 
服务器收到请求后发送给客户端资源文件等
  * 
客户端解析得到的资源文件，如果还有需要(如网页图片等)，会继续发送请求。
  * 
渲染给用户
  * 
关闭连接

**TCP 连接的过程和特点，TCP为什么需要三次握手？两次可以吗？**

![](../wKioL1LSW6rjI1nhAAE63Uv8ZRY731.jpg)

  * 
第一次：客户端告诉服务器我要和你通信，同时同步序列号为你可以用该序列段起始地址回应我。（这些字段的作用是这样的：通过SYN=1，ACK=0告诉server这是连接请求Connection Requet。SEQ=x表明后面传送数据时的第一个数据字节的序号是x+1）
  * 
第二次：服务器说，好的，你可以发送数据了；用这个序列号作为起始数据段来回应我；(server通过SYN=1，ACK=1告诉client，这是接受请求Connection Accepted。确认你是要从x+1传起了。server也通知client，我要传给你的是从y+1传起的哦！）====此后服务器资源已经分配了，而客户需要第三次才分配，所有DDOS攻击
  * 
第三次：客户端说，哦好的，我知道你准备好了，那么接下来我发送数据了哈！（但是第三次理论上可以带数据，没有SYN标志即可，client告诉server，OK，我是要建立连接，你可以建立了！第三次不带数据就不会消耗序列号，带了就消耗）

  所以必须三次握手啊，如果第三次没有而只有两次，那么如果第二次服务器发的丢失了或者其他原因客户没收到，那么服务器以为客户收到了一直等待，而客户就一直等待服务器反馈知道遇到指定的同步序列号才行，所以服务器发送其他的即使客户收到了，但同步号不对也会忽略，那么客户就等着吧永远不会连接上。<br>
特点：
* 
没有应用层的数据
* 
SYN这个标志位只有在TCP建产连接时才会被置1
* 
握手完成后SYN标志位被置0

**TCP四次挥手**

![](../20130726025024631.jpeg)
  * 
客户端得到所需，然后说我好了，需要断开了，FIN=1。你可以用同步序列号为起始回应我
  * 
服务器说，好的，那我准备关闭，把没发完的数据给你。
  * 
服务器说：我已经关了，你没机会了。FIN=1
  * 
客户端：好吧，你真快，那我也关了。双方结束！<br>
TCP连接是全双工的，所以双方都要关闭。

**UDP与TCP的区别，应用场景。**<br>
  * 
TCP连接是全双工的，是面向连接的；而UDP不需要连接，不可靠信道。
  * 
TCP可靠稳定的传输，UDP只保证最大努力交付，不可靠不稳定。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付
  * 
TCP可以传大量数据，UDP少量
  * 
TCP慢效率不高易受攻击，UDP快比TCP安全一点(不需要建立连接)
  * 
TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的
UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
  * 
每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信
  * 
TCP首部开销20字节;UDP的首部开销小，只有8个字节

<br>
**那么到底是用UDP还是TCP呢？**
  * 
  UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。如QQ语音、视频等
  * 
TCP适用于对网络环境或通讯质量要求高的环境：数据需要准确无误的发送给对方时，如HTTP、HTTPS、SMTP、FTP，QQ文件传输等
  * 
如果是由客户端间歇性的发起无状态的查询，并且偶尔发生延迟是可以容忍，那么使用HTTP/HTTPS吧。
  * 
如果客户端和服务器都可以独立发包，但是偶尔发生延迟可以容忍（比如：在线的纸牌游戏，许多MMO类的游戏），那么使用TCP长连接吧。
  * 
如果客户端和服务器都可以独立发包，而且无法忍受延迟（比如：大多数的多人动作类游戏，一些MMO类游戏），那么使用UDP吧。

**UDP与TCP优缺点**<br>
  * 
TCP慢效率不高易受攻击，UDP快比TCP安全一点(不需要建立连接)
  * 
TCP可靠稳定，UDP相反

**DNS域名解析过程及协议**
* 
第一步： 客户端发出域名解析请求， 将该请求发送给本地域名服务器(一般浏览器也有自己的缓存，这个是第一次查找的对象)；本地域名服务器是配置网络连接的时候配置的
* 
第二步：本地域名服务器收到请求后， 先查询本地缓存，若有缓存， 直接将结果返回给客户端。
* 
第三步：若本地无缓存，则本地域名服务器直接将请求发送给根域名服务器。然后根域名服务器返回给本地一个子域名服务器。
* 
第四步：本地域名服务器重定向返回的子域名服务器。向子域名服务器发送请求， 子域名服务器接收请求后，查询自己的缓存， 如果没有，则返回相关的下级域名服务器的地址。
* 
第五步：重复第四步，直到找到正确的记录。
* 
第六步：本地域名服务器把返回的结果保存到缓存中，以备下次使用。同时将结果返回给客户端。

**ARP过程**<br>
IP地址获得物理地址<br>
* 
当主机A向本局域网上的某个主机B发送IP数据报时，就先在自己的ARP缓冲表中查看有无主机B的IP地址。
* 
如果有，就可以查出其对应的硬件地址，再将此硬件地址写入MAC帧，然后通过以太网将数据包发送到目的主机中。
* 
如果查不到主机B的IP地址的表项。可能是主机B才入网，也可能是主机A刚刚加电。其高速缓冲表还是空的。在这中情况下，主机A就自动运行ARP。
  * 
ARP进程在本局域网上广播一个ARP请求分组。ARP请求分组的主要内容是表明：我的IP地址是192.168.0.2，我的硬件地址是00-00-C0-15-AD-18.我想知道IP地址为192.168.0.4的主机的硬件地址。
  * 
在本局域网上的所有主机上运行的ARP进行都收到此ARP请求分组。
  * 
主机B在ARP请求分组中见到自己的IP地址，就向主机A发送ARP响应分组，并写入自己的硬件地址。其余的所有主机都不理睬这个ARP请求分组。ARP响应分组的主要内容是表明：“我的IP地址是192.168.0.4,我的硬件地址是08-00-2B-00-EE-AA”,请注意：虽然ARP请求分组是广播发送的，但ARP响应分组是普通的单播，即从一个源地址发送到一个目的地址。
  * 
主机A收到主机B的ARP响应分组后，就在其ARP高速缓冲表中写入主机B的IP地址到硬件地址的映射。

**ABC 类地址**

![](../QQ截图20160617152050.png)
* 
网络号+主机号 或者 网络前缀+主机号
    * 
比如：185.46.54.45/24。表示24位的网络前缀(网络号+子网号)，12位主机号====子网掩码就是255.255.255.0
    * 
子网号是从主机号借来的；子网掩码就是网络号+子网号均是1，主机号为0，两个IP的掩码就是相同的
* 
全0是本机地址，全1是广播地址，主机号全0是网络本身
* 
网络前缀相同的连续IP可以路由聚合或称超网，相同的个数可以作为/n中的n

A类IP地址<br>
一个A类IP地址由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是"0"， 地址范围```从1.0.0.0 到126.0.0.0```。可用的A类网络有126个，每个网络能容纳1亿多个主机

B类IP地址<br>
一个B类IP地址由2个字节的网络地址和2个字节的主机地址组成，网络地址的最高位必须是"10"，地址范围```从128.0.0.0到191.255.255.255```。可用的B类网络有16,382个，每个网络能容纳6万多个主机 。

C类IP地址<br>
一个C类地址是由3字节的网络地址和1字节的主机地址组成，网络地址的最高位必须是"110"。范围```从192.0.0.0 - 223.255.255.255``` C类网络达209万余个，每个网络能容纳254个主机。
分享本回答由电脑网络分类达

![](../QQ截图20160617152112.png)


**常用的端口号:0~65535共65536个，0~1023号一般都是系统的**

| 层数 | 协议与端口号 | 备注 |
| -- | -- | -- |
| 1 物理层 |  | 负责比特信号的传播 |
| 2 数据链路层 |  | 帧 |
| 3 网络层 | IP、ARP、ICMP、RIP | 数据报 |
| 4 传输层 | TCP、UDP | 数据报，屏蔽底层细节 |
| 5 会话层 | |  |
| 6 表示层 | |  |
| 7 应用层 | DNS-53、FTP-20/21、TELNET-23、SMTP-25、POP3-110、DHCP、HTTP-80、HTTPS-443 |  |

**拥塞控制**<br>
滑动窗口：<br>
* 
比如滑动窗口大小为4KB，也就是说发送方只能发送4KB(这4KB未经确认，如果确认一个则发送方可以再发一个)。
* 
接收方接收到一个，就发一个确认，那么发送窗口就向前滑动一个即可以再发一个

拥塞相关：
* 
接收端根据接收缓存的大小，动态调整发送端窗口大小：接收窗口rwnd。在接收方的TCP包头部，发送方收到后，就按此次大小（单位字节）发送数据；
* 
发送方对当前网络的拥塞程度估计得到窗口：拥塞窗口cwnd。
    * 
慢开始和拥塞避免
    * 
快重传和快恢复

拥塞控制：防止发送过多数据给网络，造成路由等过载，增加负荷；===全局的<br>
流量控制：防止发送过多导致接收不了。====端对端的<br>
所以说发送多少是按照接收窗口和拥塞窗口一起控制的，**最小值**！

**[session](http://www.cnblogs.com/kissdodog/archive/2013/02/08/2909292.html)放在哪里？如何保存会话状态**

**nignx的异步模型与事件管理**


[返回目录](README.md)