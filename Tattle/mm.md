* 
###一、C++
    * C++实现反射：工厂模式，提供注册与管理的类，一个中间负责注册调用的类，一个具体的基类，其他继承此；
    * [c++模板](./../C++/temp.md)：
        * 函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化 
必须由程序员在程序中显式地指定。
        * 函数模板：仅可以字面值，参数推演
        * 类模板：类型实例化、不可以推演
        * 两者区别：上述，还有就是函数模板不能有模板参数
        * 三种参数：类型参数、非类型参数、模板参数  ```template<typename T1, int a, typename T2 = int>```
        * 函数返回为啥有typename：因为编译器不知道你是啥类型：函数、变量还是别的，告诉他是类型用的。
        * [traits](./../C++/stl/shix.md)：类型萃取器
        * 特化：支持特定的属性。有些不用做模板
            * 全特化：非类型参数
            * 偏特化：函数不支持
    * c指针数组： 
        * 数组不可以拷贝和赋值；
        * 函数参数时数组自动转换为指针；
        * ```int i[10]; int *p = i;  　　　　sizeof(i) = 40, sizeof(p) = 4;```
    * sizeof、strlen
        * 运算符：函数
        * 内存字节数：长度
        * 编译：运行
        * 任意类型：字符串
        * 数组不退化：退化为指针
    * java和c++的赋值都啥不同：
        * 在C++中将一个名为O2的对象的数据复制给O1,即存在两个对象，他们的值相同。
        * 在Java中，这句话只是把O2对象的引用复制给了O1，此时它们指向同一个对象，即只存在一个对象 
        * 深拷贝和浅拷贝的区别
    * const和static能不能同时使用：
        * static const 与 const static没有任何区别
        * 普通：可以
        * 类内：
            * C++11后现在都可以
            * 之前只能用static const;
    * 指针和引用的区别
        * 最本质的区别就是指针分配内存，引用只是别名，没有内存
            * 指针不必初始化，引用必须初始化
            * 指针可以delete，引用不可以
            * 指针可以为NULL，引用不可以
            * 指针修改的自身指向，引用修改的绑定的对象
    * 重载函数怎么实现？    
        * C++编译时，产生的符号表内部函数名包含参数
    * inline关键字的作用? 有什么缺点?
        * 向编译器发出请求，在对应的地方展开代码。编译器可以忽略该请求
        * 缺点：代码膨胀（展开处过多、inline代码太长）
    * 继承和组合的区别？
        * 继承(正常)：派生与基类的关系，包含：“白猫是猫”，“黑人是人”
        * 组合(一个类是另一个的成员)：含有的关系，属性；
    * [类成员变量、函数](./../C++/class.md)：
        * 成员：
            * 普通
            * 静态
        * 函数：
            *  普通
            *  静态
            *  虚函数
    * C++构造函数和析构函数可以声明为私有么? 这样声明使用时候需要注意什么：
        * 可以。注意不要让用户调用
    * 为什么析构函数要为虚函数：    
        * 比如我们有一个指向派生类的基类指针，析构函数是非虚函数，那么删除该指针时会调用基类析构，派生类永远不会调用
    * 异常安全性（构造和析构）：
        * 构造：可以产生未处理异常，编译器会把已经构造的部分析构掉
        * 析构：不可以产生未处理异常，可能会导致对象未被析构完全或者处理异常时又有异常，那么永远不会被析构
    * Raid：
        * 资源获取即初始化
    * [智能指针](./../C++/ptr.md)：
    * C++多态如何实现：
        * 通过基类中定义或者声明了虚函数，派生类重新定义实现虚函数
        * 基类指针指向派生类的对象
        * 通过该指针
    * [虚函数、虚函数表](./../C++/class.md)：
    * 虚基类（接口）：
    * 普通继承、多重继承：
    * 菱形继承、虚继承：
    * explicit的作用：
        * 不可隐式转换，仅可以直接初始化，不可以间接初始化
        * int i(10) //可以  　　　　　int i = 10;//不可以
    * [static两类五个](./../C++/static.md)：
    * 四个强制类型转换、C风格：
        * C风格：不做任何保证，直接暴力转换。但是数据的原始属性并没有改变；
        * static_cast：non-const到const、void与普通互换、精度问题认为用户保证、子类转换为基类(不安全)
        * const_cast：仅用于消除const属性；const到non-const
        * dynamic_cast：尽可以对象的指针和引用；下行有安全检查；上行没有
        * reinterpret_cast：位模式下的转换。同C本身格式没变！
    * dynamic_cast与直接(Class \*)类型转换
        * dynamic_cast下行转换时有安全检查
    * c/c++中函数调用的过程（参数压栈，call压返回地址，压ebp，保存现场）：
        * 参数入栈（此时在调用者栈里）
        * 返回地址入栈（此时仍在调用者栈里）
        * 进入被调用函数，建栈等
        * 压入ebp，保存现场（进入了被调用者栈里）
        * 执行，返回退栈。
        * 获得栈底的ebp值，找到调用者栈
        * 继续
    * c/c++变长参数：第一个是个数，三个标准宏va_start、va_arg、va_end
    * 宏一般的用处、不可被const取代的方面、typedef：
        * 宏：整个程序内替换，编译期完成没有类型检查，文本替换=====不分配内存，编译
        * const：当前文件替换，有内存，有类型检查======分配内存，是运行时的概念
        * typedef：更好的封装性、可读性，只是一个新名字；宏定义只是简单的文本替换
    * 内联与宏
        * 内联有参数类型检查
        * 内联可以访问类的成员变量
    * 上述两者各有那些优缺点：
        * 宏不会做安全检查及类型检查
        * const有类型检查，更可靠
    * int \*p[]与int (*p)[]的区别：
        * 指针数组：保存指针的数组
        * 数组指针：指向数组的指针。```int (*p)[];int a[10];p =a ;```
    * 函数参数int []和int \*有没有区别：
        * 参数会将数组名自动转换为对应的指针：没有区别
        * 但是二级有区别：int **不会调用int a[][]，相反也不会；
    * 堆和栈的区别：
        * 管理者、访问速度、碎片、方向、大小
    * 栈溢出攻击是什么原理：
        * 堆溢出是因为内存泄漏
        * 函数调用时，没有参数大小检查。参数大小超过了缓冲区的大小从而产生溢出导致覆盖其他信息；如果这些信息被精心设计过，写到对应的地方，那么就会导致程序执行流程被劫持
    * const int \*, int const \*, int * const区别：
        * const在*左边，底层const，可以改自己，不可以改自己指向的对象
        * const在*右边，顶层const，不可以改自己，可以改自己指向的对象
    * gcc编译链接时候有多个库需要链接，那么链接顺序需要注意什么：
        * 库的查找：从右向左，最后一个-l库文件最先调用；根据-L指定的路径顺序查找；
        * 在项目开发过层中尽量让lib是垂直关系，避免循环依赖；越是底层的库，越是往后面写！
　　　　　　　　　　　　　　　```g++ ...  obj($?) -l(上层逻辑lib) -l(中间封装lib) -l(基础lib) -l(系统lib)  -o $@```
    * C++语言中extern C有什么用处：
        * 因为C++会将函数名和参数联合起来生成一个中间的函数名称，而C语言不会，所以链接时会有找不到定义；
        * 用extern “C”进行链接指定，这告诉编译器，请保持我的生成规则；
    * C++深拷贝和浅拷贝是什么? 深拷贝一般过程是什么样? 每次深拷贝都要拷贝一遍么?
        * 深拷贝采用的是从新申请一块内存，将数据拷贝过来；
        * 浅拷贝只是指针的拷贝，共享一个内存空间
        * 特别注意指针赋值时；
    * C++11特性了解哪些：auto、decltype、nullptr、for、smart-pointer、lambda、move语义和右值引用、override-final、多线程及信号量和锁、unordered-map、regex、bind、原子类型等
    * 异常机制：异常处理允许用户以一种有序的方式管理运行是出现的错误。
        * 把可能出现异常的代码和异常处理代码隔离开,结构更清晰.    
        * 把内层错误的处理直接转移到适当的外层来处理,化简了处理流程.传统的手段是通过一层层返回错误码把错误处理转移到 上层,上层再转移到上上层,当层数过多时将需要非常多的判断, 以采取适当的策略. 
        * 局部出现异常时,在执行处理代码之前,会执行堆栈回退,即为所有局部对象调用析构函数,保证局部对象行为良好. 
        * 可以在出现异常时保证不产生内存泄漏.通过适当的try,catch 布局,可以保证delete pobj;一定被执行. 
        * 在出现异常时,能够获取异常的信息,指出异常原因. 并可以给用户优雅的提示. F.可以在处理块中尝试错误恢复.保证程序几乎不会崩溃.
    * 
* ###二、[GDB](http://www.cnblogs.com/lidabo/p/4234362.html)
    * gdb的用法，说说常用的那些调试命令，怎么产生dump文件，怎么设置条件断点，怎么设置观察断点
        * help、b、bt、r/c、s/n、p、watch、d等
        * 产生core dump(核心转储)文件：（linux一般禁止生成）
            * 编译时加上-g；
            * ulimit -c unlimited  //unlimited 表示不限制生成的core文件的大小。
        * 条件断点
            * break [break-args] if (condition) 　```break 180 if (string == NULL && i < 0)```　　
            * ```condition <break_list>　(condition)```：只是condition只能用在已存在的断点上。
        ```cond 3 i == 3　将会在断点3上附加条件（i == 3）```
        * 观察断点，为表达式（变量） expr设置一个观察点，一量表达式值有变化时，马上停住程序。
            * ```watch <expr> ``` ：有变化及通知停住
            * ```rwatch <expr>```：表达式/变量被读时，停住
            * ```awatch <expr>```：被写时
    * 多线程调试时候,怎么切换到另外的线程呢?
        * 查询线程：info threads  　　  info inferiors
        * 切换调试线程：```thread <thread number>　　　inferior <infer number>```
    * 问: 你这里说你熟悉GDB,你平时是分析dumpcore还是单步调试?
    * 问: 那么你知道gdb中被调函数中想打印上层函数局部变量怎么打印么?
        * 域操作符：： 
        * print [file]::x
        * print [func]::x
    * 问: 那多线程调试时候,怎么切换到另外的线程呢?
    * 问: 还有你说你熟悉git, 那么怎么远程添加分支?
        * git push remote-name local-branch:remote-branch
    * 问: 那你平时用一些啥命令?
    * gdb平时用哪些命令? s/n区别?
        * 都是单行，S是进入调用函数，N是执行调用函数
    * 怎么查看内存地址上的数据?
        * bt、p
    * coredump怎么用？
    * 如果一个cpp文件包含两个头文件，这两个头文件分别**定义**了一个同样的函数，会在g++的哪个阶段报错? <br>====》这个我没答出来，只觉得要么是编译阶段，要么是汇编阶段，后来会去试了一下是编译阶段，<br>  
        * 肯定是编译：头文件是文本替换啊，重复定义
* ###三、STL
    * vector实现以及删除中间的元素
        * 底层使用数组；可以随机访问元素，尾后插入比中间快
        * 增、删、查、改的过程，可能引起的改变等
        * 添加和删除中间的元素都是导致之后的元素移动
        * 添加：返回第一个添加成功元素的迭代器。可能所有迭代器失效
        * 删除：返回删除成功后第一个元素迭代器。只有后面的迭代器失效
    * map实现机制
        * map的实现是基于RBTree的，以键值对为单位进行查找
    * map为什么用[红黑树](./../DataStructure/search.md)而不是AVL：
        * 需要考虑的是：查找search、插入insert、删除delete时的功能、性能、时空复杂性效率；
        * 因为 AVL 树是高度平衡的树, 而每一次对树的修改, rebalance的可能要比红黑树高的多, 这里的开销会比红黑树大. 红黑树插入只要两次旋转和AVL相同,O(1)复杂度；<br> 删除至多三次旋转，但是AVL可能多次从被删节点一直到根节点. 但不可否认的是, AVL 树搜索的效率是非常稳定的. 选取红黑树, 是一种折中的方案.
        * AVL更平衡，结构上更加直观，时间效能针对读取而言更高；维护稍慢，空间开销较大；
<br>红黑树，读取略逊于AVL，维护强于AVL，空间开销与AVL类似，内容极多时略优于AVL，维护优于AVL。
    * C++里面的STL实现你都了解哪些？ 具体说一说?
        * 六大组件：容器、算法、迭代器、适配器、仿函数、配置器
        * 配置器分两级：128B；链表、内存池
* ###四、设计模式
    * 工厂模式：定义一个用于创建对象的接口，让子类决定实例化那个类。使得一个类的实例化延迟到子类。
    * [单例模式](./../C++/singleton.md)怎么编写? 保证类只有一个实例，并提供一个全局的访问点
    * 适配器：将类的接口转换为客户希望的接口。使得不兼容的接口一起工作。
    * 观察者：定义对象间一对多的依赖关系，以便一个对象发生变化时通知依赖它的其他对象。
    * 装饰：动态的给一个对象添加一些额外的功能。
* ###五、算法设计:
    * 将ip字符串转换为int[]的程序
        * strtok的使用：第一次是源串，第二次设NULL
        * unsigned int 足够保存
        * ```C++
        uint ipTint(char *ipstr)  
            {  
                if (ipstr == NULL)  return 0;  
               
                char *token;  
                uint i = 3, total = 0, cur;  
               
                token = strtok(ipstr, ".");  
               
                while (token != NULL) {  
                    cur = atoi(token);  
                    if (cur >= 0 && cur <= 255) {  
                        total += cur * pow(256, i);  
                    }  
                    i --;  
                    token = strtok(NULL, ".");  
                }  
               
                return total;  
            }   
        ```
    * 闰年
        * 该年能被4整除，但是不能被100整除
        * 该年能被400整除
    * 四十亿个QQ号，每个QQ号有16字节的昵称，给你**一批**8GB内存的机器，设计一个系统使得查询速度最快
        * QQ号和昵称有映射关系
        * 一个主服务器，多个从服务器，先根据QQ映射到对应从服务器，然后在对应从服务器上找，从服务器上可以把自己字段通过哈希映射到内存中
        * 如果有一台机器被查询的次数很多？
            * 采用缓存
    * 两个100MB的文件里面存放着QQ号，找出相同的QQ号：
        * bitmap：每一个bit代表一个qq号
        * 或对两个文件根据qq的hash值分割成小文件，比较小文件
    * 归并排序是否需要额外的空间：链表的不用 数组的要
    * [归并、快排写法](./../DataStructure/sort.md)
    * 字符串如何hash 
        * 对于字符串Hash来说都是把**字符串映射为一个整数**，这一步是通过Hash函数来进行的。常用的Hash函数具体有：
SDBMHash，RSHash，JSHash，ELFHash，BKDRHash，DJBHash等等：
```C
unsigned int ELFhash(char *str)  
{  
                unsigned int h = 0;  
                unsigned int x;  
                while(*str)  
                {  
                    h = (h << 4) + *str++;  
                    x = h & 0xF0000000L;  
                    if(x)  
                    {  
                        h ^= x>>24;  
                        h &= ~x;  
                    }  
                }  
                return h & 0x7FFFFFFF;  
}  
接下来详细探讨它的原理。
（1）h = (h << 4) + *str++;  把当前的字符的ASCII存入h的低4位。
（2）x = h & 0xF0000000L;    取出h中最高4位，0xF0000000L地代表28~31这4位是1，其余后28位是0。
（3）如果最高4位不为0，那么说明字符多于7个，现在正在存第8个，如果不处理再加下一个字符时，第一个字符会
    被移出，因为1~4位刚刚加入了新字符，所以不能>>28，而是>>24。
（4）h &= ~x;                表示把h的高4位清零。```
    * url如何hash
    * 哈希表的size为什么总是一个素数？
        * 减少冲突的产生
    * 字符串匹配都有哪些算法?
    * 海量日志数据，提取出某日访问百度次数最多的那个IP 
        * 现将IP地址做hash映射，分成1024或者更多、更少的小文件
        * 逐个读取每个小文件，建立一个IP为key，出现次数为value的HashMap；
        * 出现过加1，没有为1
        * 遍历完所有小文件即可，比较这些HashMap中最大的那个即可；
    * 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？ 
        * 第一步对每个url取hash值，对应的值为小文件的编号；拆分两个文件；比如每个大文件拆分为1000个小的，每个小的就是5G*64/1000 = 300M
        * 对应小文件一个一个的对比，找到相似的即可；set就行了；
    * 有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。 
        * 对query取hash值，放到1000个小文件中，
        * 统计每个小文件中query的出现情况；
        * 对所有小文件的统计情况排序
    * 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。 
        * 先统计所有单词的出现次数
            * 根据单词的hash值分成10000个小文件，统计每个小文件中每个单词出现的个数；
        * 堆排序：小顶堆
    * ###**海量数据处理**：
        * 遍历所有：先hash**分而治之**，降低规模；然后对小文件一个个处理
        * 最大的某些：堆排序
    * 只扫描一遍如何判断一副牌是否胡了？？
        * 一般胡牌：三个加一个对
            * 我们把所有的可能记录，比如111（算一项），123，一直到，789，999（万、条、饼区分开算：即三个111，记录区分好即可或者用三个数组）。那么当我们扫描到1的时候就把所有带1的项都加1。
            * 最后遍历所有，只要该项值为3即可。
* ###六、操作系统：
    * 生产者-消费者伪代码：多个生产者与多个消费者共享多个缓冲区的事情
    ```C++
        item B[k];
        semaphore empty;    empty=k;   //可以使用的空缓冲区数
        semaphore full; full=0;        //缓冲区内可以使用的产品数
        semaphore mutex;    mutex=1;   //互斥信号量
        int in=0;                      //放入缓冲区指针
        int out=0;                     //取出缓冲区指针 
        cobegin
        process producer_i ( ) {        process consumer_j( )   {    
               while(true) {                 while(true) {
               produce( );                   P(full);
               P(empty);                     P(mutex);
               P(mutex);                     take( ) from B[out];
               append to B[in];              V(empty);             
               in=(in+1)%k;                  out=(out+1)%k;     
               V(mutex);                     V(mutex);  
               V(full);                      consume( );
                          }                               }
                            }                                }
        coend
原理：
    semaphore
    {
        int value;          // 
        PCBtype *wait_queue;//阻塞的队列
    }
    P：操作时减1，如果value大于0执行，小于0进入阻塞队列
    V：操作时加1，如果value大于0，继续；如果小于等于0，唤醒一个
    ```
    * 如何查看进程是否内存泄露?进程执行时间过长分析原因？
        * 静态检查: valgrind 
        * 动态检查：vim /proc/pid/status VmData项数值即为进程使用的堆大小，实时观察该值，是不是在不断的一直变大，说明有可能内存泄露
    * strace命令用过么? 
        * strace命令是用来查看进程所涉及到的系统调用：调用的函数名及返回值
    * 进程内核态时间较多一般是什么原因? 　　　　　　　母鸡啊！
    * IPC有哪些？哪个最快？
        * 共享内存：最快
        * 消息队列：内核空间，
        * 信号量：一个计数器，统计当前访问资源的进程数
        * 管道、有名管道：一个只能亲属关系，另一个任意
        * 套接字：与其他系统通信
        * 信号：时间发生时用于通知别的进程
    * 一定量的数据向一个文件里面写和向两个文件里面交叉写哪个更快? 如何查看磁盘是否繁忙?
        * 我认为一个快，两个还要打开两次。当然如果两个进程近更快了
        * iostat信息，查看当前使用的句柄个数
    * 怎样判断机器大小尾端？
        * 申请一个int,只读一部分
        * 或者通过使用union：共享的特性，给一个大的赋值，读小的看是大的的那一部分即可
        ```C++
            typedef union
            {
            　　char ch;
            　　int    data;
            }Udata;
            int main()
            {
            　　Udata tmpData;
            　　tmpData.data = 0x12345678;
            　　if(tmpData.ch == 0x78)
            　　{
            　　　　printf("Little-endian\n");
            　　}
            
            　　else if(tmpData.ch == 0x12)
            　　{
            　　　　printf("Big-endian\n");
            　　}
            　　else
            　　{
            　　　　printf("Unable to determine\n");
            　　}
            　　return 0;
            }
        ```
    * awk，sed,grep：分析处理、编辑、查找
    * iptables五个钩子：
        * PREROUTING (路由前)
		* INPUT (数据包流入口)
		* FORWARD (转发管卡)
		* OUTPUT(数据包出口)
		* POSTROUTING（路由后）    
    * linux core文件：
        * 在一个程序崩溃时，它一般会在指定目录下生成一个core文件。core文件仅仅是一个内存映象(同时加上调试信息)，主要是用来调试的。   
    * traceroute使用
        * 是用来发出数据包的主机到目标主机之间所经过的网关的工具。
        * 从你的计算机到互联网另一端的主机是走的什么路径
    * 有一个文件里面每行存储ip user query_id三项，然后找出出现次数最多的query_id的所有行． 我很艰难的写了 query_id = cat file | awk '{ print $3} | sort | awk '{ ...}''; cat file | '($3 == $query_id){ print $0}', 面试官说我写的复杂了...
    * shell脚本了解么?file.txt每行有两列数据，第二列是数字，求所有行第二列数据和?
    * 编译，链接，装载到内存：
        * 编译：负责将上层语言编译为汇编语言
        * 汇编：将汇编语言解释为机器语言
        * 链接：将有关文件彼此链接在一起
        * 装载：当系统调用函数时，将代码加载到内存中。
    * 讲讲链接器，静态链接和动态链接的优缺点，
        * 由于编译、汇编后的目标文件不能执行：比如某个文件引用了另一个的符号等
        * 将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来
        * 分为两种：
            * 静态链接：函数的代码将从其所在地静态链接库中被拷贝到最终的可执行程序中。==》最终可执行文件比较大（每一个都有一份拷贝）
            * 动态链接：函数的代码被放到称作是动态链接库或共享对象的某个目标文件中。可执行程序只需要记住地址等一些信息即可====》可执行文件小（只有一个拷贝）
    * 进程执行，挂起，调度，调用共享库，
    * 系统调用：
    * I/O...
    * 内存管理、虚拟内存的概念：
    * 进程的虚拟地址到物理地址怎么进行的转换：
        * 直接相连（高位对cache块数取余）、全相连、组相连
    * 内存通道，并行单元
    * 分段的核心思想是什么：
        * 分页是系统
        * 分段是根据用户程序
    * 进程虚拟地址空间的实现
    * select, poll和epoll的差别
        * select有大小限制，一般1024，可以配置。
        * select和poll都会修改传入的数组，所有会有两次拷贝的过程，比较慢；
        * select和poll都不会告诉那个有变化，需要自己遍历
    * 使用epoll的高并发服务器(详细，线程池以及epoll监听过程)
    * select和epoll的区别？ epoll有哪几种触发？ 各有什么特点？
        * 水平触发LT：可以当前不处理，下次还报告
        * 边缘触发ET：当前不处理以后不报告了
        * 默认水平触发LT
    * pthread_cond_signal唤醒几个线程
    * 信号量怎么实现的?
    * [fork()流程](./../C++/C_relatives/thread.md)，如文件描述符存储位置，写时复制技术，clone函数等
        * fork、vfork等函数内部都是sys_fork实现的
        * 调用do_fork()：生成新的PID，调用copy_process；
        * copy_process以父进程副本的形式拷贝；调用dup_task_struct，生成新的task_struct
        * 返回给copy_process完成task_struct的初始化，返回给do_fork
    * fork 函数：如何确认是子进程还是父进程
        * 返回0是子进程 大于0是父进程，表示子进程pid
    * 进程和线程、进程的创建及运行过程，进程通信过程，进程调度，线程安全, 进程间互斥的理解
    * 进线程优缺点：
        * 进程是申请资源的最小单位，线程是调度的最小单位；
        * 线程共享进程资源：调用栈、变量、缓冲区等；共享堆空间，独立自己的栈空间
        * 线程容易切换，进程切换效率低有两次模式切换；
        * 一个线程不正常死亡，可能导致整个进程出问题；所以多进程+多线程合作最好
    * 共享内存如何实现的?
        * 在内核里面申请一块内存作为通信的文件
        * 首先申请内存，然后**映射到自己的地址空间**即可（mmap映射过来）
        * 对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次数据[1]：一次从输入文件到共享内存区，另一次从共享内存区到输出文件。
    * 管道又是怎么实现的?
    * 两次(共享内存)和四次(消息队列、管道)
        * 4次：1，由用户空间的buf中将数据拷贝到内核中。2，内核将数据拷贝到内存中。3，内存到内核。4，内核到用户空间的buf.
        * 2次： 1，用户空间到内存。 2，内存到用户空间。
    * 线程与协程的区别：
        * 一个线程可以有多个协程
        * 协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。线程是OS调度
        * 协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。
        * 协程可以理解为用户态的轻量级线程
        * 打个比方，假设有一个操作系统，是单核的，系统上没有其他的程序需要运行，有两个线程 A 和 B ，A 和 B 在单独运行时都需要 10 秒来完成自己的任务，而且任务都是运算操作，A B 之间也没有竞争和共享数据的问题。现在 A B 两个线程并行，操作系统会不停的在 A B 两个线程之间切换，达到一种伪并行的效果，假设切换的频率是每秒一次，切换的成本是 0.1 秒(主要是栈切换)，总共需要 20 + 19 \* 0.1 = 21.9 秒。如果使用协程的方式，可以先运行协程 A ，A 结束的时候让位给协程 B ，只发生一次切换，总时间是 20 + 1 * 0.1 = 20.1 秒。如果系统是双核的，而且线程是标准线程，那么 A B 两个线程就可以真并行，总时间只需要 10 秒，而协程的方案仍然需要 20.1 秒。.
    * 多线程共享那些东西
        * 进程代码段、进程的公有数据(利用这些共享的数据，缓冲区、全局变量、地址空间等)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。
        * 不共享：线程自己的堆栈（运行函数时）、线程ID、优先级、寄存器组（程序计数器、寄存器等）的值等
    * 进程和线程、协程切换的差异，各自的上下文包括什么
        * 进程：保存寄存器、程序计数器、更换队列、更新状态。恢复时在反向来一遍。所以有两次模式切换：用户-内核、内核-用户
        * 线程：无法利用多核
            * 用户级：只需要保存用户寄存器的内容，程序计数器，栈指针，不需要模式切换。
            * 内核级：内核完成，用户没有权限
        * 协程：协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。
        * 进程间不共享任何东西：堆、栈等；协程和线程共享堆，但是不共享栈；
    * 状态：
        * 进程：运行、就绪、阻塞
        * 线程：创建、就绪、运行、阻塞、终止
    * 文件系统的概念及框架、实现的过程：
    * open /usr/abc.txt这么一个文件，怎么操作的？
    * Linux读写文件的流程
    * VFS重要的数据结构
    * mmap和directIO效率，优缺点
    * 进程之间通信的途径答案：共享存储系统消息传递系统管道：以文件系统为基础 
    * 进程死锁的原因答案：资源竞争及进程推进顺序非法 
    * 死锁的4个必要条件答案：互斥、请求保持、不可剥夺、环路 
    * 死锁的处理答案：鸵鸟策略、预防策略、避免策略、检测与解除死锁 
    * 操作系统中进程调度策略有哪几种？答案：FCFS(先来先服务)，优先级，时间片轮转，多级反馈 
    * Linux中锁：
        * 读写锁：区分读和写，符合条件时允许多个线程访问对象。处于读锁操作时可以允许其他线程和本线程的读锁， 但不允许写锁， 处于写锁时则任何锁操作都会睡眠等待；
            * 读锁时可以加读锁不可以加写锁，但是为了防止写锁无线等待，当有写锁时接下来的读锁都会阻塞。
        * 互斥锁：用于线程的同步，同一时间只有一个可以访问。如互斥量、信号量、临界区等！加锁不成功则等待。
        * 自旋锁：也是用于线程同步，但是加锁不成功不会睡眠等待，而是不断询问。减少模式切换的时间，但是若持有锁的时间较长不好！
        * 互斥锁的起始原始开销要高于自旋锁，但是基本是一劳永逸，临界区持锁时间的大小并不会对互斥锁的开销造成影响，而自旋锁是死循环检测，加锁全程消耗cpu，起始开销虽然低于互斥锁，但是随着持锁时间，加锁的开销是线性增长。
    * Linux锁怎么实现的
    * Linux文件共享怎么实现的
* ###七、[数据库](./../mysql/know.md)
    * SQL语句及索引的优化
        * 尽量不在where中判断NULL
        * 尽量避免在 where 子句中使用 != 或 <> 操作符，否则将引擎放弃使用索引而进行全表扫描。
        * 尽量避免在 where 子句中使用 or 来连接条件
    * 数据库表结构的优化
    * 系统配置的优化
    * 硬件的优化
    * 数据库索引：
    * Innodb、以及另一种方式
        * Innodb：
        * Myisam：默认的，但是不支持事务、外键、行级锁
    * mysql where 和 on的区别：
        * where：是对生成的临时表起作用
        * on：在生成虚表时使用的，不管真假左边的肯定都有
    * 怎么保证ACID：
    * 数据库123范式：
    * SQL操作：
* ###八、Python
    * python装饰器 
        * 在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator） 
        * 本质上，decorator就是一个返回函数的高阶函数：参数也是函数
        ```python
        def log(func):
            def wrapper(*args, **kw):
                print('call %s():' % func.__name__)
                return func(*args, **kw)
            return wrapper
        @log
        def now():
            print('2015-3-25')
        >>> now()
        call now():
        2015-3-25
        # 即相当于now = log(now)
        ```
    * GIL (Global Interpreter Lock)
        * 每一个interpreter进程,只能同时仅有一个线程来执行, 获得相关的锁, 存取相关的资源.
        * 在多线程环境下，任何一条线程想要执行代码的时候，都必须获取（acquire）到这个锁，运行一定数量字节码，然后释放（release）掉，然后再尝试获取。这样 GIL 就保证了同时只有一条线程在执行。
        * 所以python根本没有利用多线程。但是好处是不用担心全局变量的锁问题
        * 对应CPU密集型操作，作用不大，但是我们的程序大多数IO密集型的。
        * 所以CPU密集型的用多进程，普通IO的用多线程。还是多进程把！
    * With：简化try...catch...finally
    ```python
    class opened(object):
        def __init__(self, name):
            self.handle = open(name)
        def __enter__(self):
            return self.handle
        def __exit__(self, type, value, trackback):
            self.handle.close()
    with opened('/tmp/a.txt') as f:
            print(line)
            
    # with 后的那个返回一个上下文管理器对象。  AS后的是调用enter方法返回的值
    ```
    * 如果去掉GIL会出现什么问题
    * Async:
    * MVC是什么?
        * MVC是一种设计模式，它强制的将应用程序的输入、处理、和输出分开。
	    1. 
使用了MVC的应用程序被分为3个核心部件:试图(View)、模型(Model)、控制器(Controller)。它们各司其职，既分工明确又相互合作。
* ###九、网络：
    * 怎样查看两台主机之间的路由情况？traceroute命令?
        * traceroute通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间.测三次，大小40B
    * TCP/IP状态转移图
        * 三次连接：
            * 客户端：closed->syn_sent->established
            * 服务端：listen->syn_recv->establish
        * 四次挥手：   
            * 客户端：established->fin_wait1->fin_wait2->time__wait->closed
            * 服务端：established->close_wait->last_ack->closed
    * 拥塞控制
        * 发送端会根据当前的路由情况估计网络的拥塞情况，估计得到一个拥塞窗口
    * 丢包的话滑动窗口会改变么？
        * 不会。重发
    * http协议了解么? TCP协议了解么?
    * tcp拥塞控制和流量控制
        * 拥塞控制：主要是考虑网络的负载情况
        * 流量控制：主要是考虑接收端的接受能力
    * tcp如何保证可靠传输：
        * 序号、确认号(下次第一个报文的第一个字节的序号)、重传等机制
    * tcp超时重传：如何区分是发送包丢了 还是ACK丢了
        * 针对每个报文段都有一个计时器，超出这个时间没有收到确认，就认为是超时
        * 收到三次同一个报文冗余ACK，就认为要重发
    * tcp无边界
    * TCP、UDP区别与各自应用
        * TCP：可靠连接按序、建立时间长、多的数据。文件传输
        * UDP：不可靠无连接尽最大可能支付、不需要建立连接、少的数据。在线语音或视频
    * 三次握手，四次挥手，为啥一个三次一个四次，FIN和ACK对应的RST是什么，其他的还有哪些
        * 如果没有最后一个握手，第二次的丢了，那么服务器和客户端一直等指定的序列号，但是两者都不会发送
        * TCP是全双工的，所以需要四次。每一个都要完全关闭。
    * OSI七层网络模型分别哪些，TCP/IP五层分别是哪些? 为什么少了两层?
        * 上三层合并叫做应用层，其他没变
        * （中继器和集线器）、（交换机及网桥）、（路由器）、（）、（）、（）
    * 网络编程send，什么时候返回，
        * 进程缓存写到kernel的socket buffer后就返回；至于什么时候发送、什么时候确认等系统调用层不care
        * 将数据拷贝到发送buffer，只有收到ack后才会清除；滑动窗口
        * 何时真正发送数据，说了中断，这里答的不好，最后面试官说了中断 上下半部处理过程
* ###十、Git:
    * 工作区、暂存区（版本库）
    * git怎么远程添加分支?
        * git push remote-name local-branch:remote-branch
    * git平时用哪些[命令](../git.md)?
        * add、commit、status、log、reflog、branch、reset|revert、checkout（两个）、push、pull、rebase|merge、fetch等
        
![](0.jpg)
![](32.jpg)

##十一.如何设计一个高并发的系统
* 
数据库的优化，包括合理的事务隔离级别、SQL语句优化、索引的优化
* 
使用缓存，尽量减少数据库 IO
* 
分布式数据库、分布式缓存
* 
服务器的负载均衡

[返回目录](README.md)