###华为面试
1. 
问他的：
    1. 
技术：
1. 
模拟器项目：
    * 
    项目描述：初步讲一下项目是什么样的；讲清楚自己做了什么，遇到了什么难题，怎么解决的？
        1. 
    项目主要是...（有什么需求，重要性！最好几句话讲完）；
        1. 
    **重点是自己做了那些东西**：
            * 
    使用了什么平台、技术（模板、转移语义等），实现了那些功能或者算法；
            * 
    基类的定义：为了以后可以扩展更多的模块
            * 
    后端模块的划分以及为什么这么划分；
            * 
    硬件模块的功能以及软件模块的定义：数据以及操作；
            1. 
    模块间接口以及传输的数据结构的定义
            1. 
    性能数据采集组件的设计与实现
        1. 
    遇到了那些困难：
            * 
    模块的划分即**建模的问题**：各个模块之间联系比较紧密，怎么划分才能更好的体现模块化；
            * 
    比如说指令流存在回路的问题：发射指令的源操作数其实并没有准备好。
            * 
    分支预测指令预测错误，需要回滚操作
            * 
    LSQ操作miss，需要重新发射
                * 
    以上四个问题：需要对模块的概念，以及硬件功能模块仔细的研究和理解，同时也需要借鉴其他模拟器的实现；比如说GEM5，两个模块之间有一个类似共享的区域；我们则通过端口化，采用move移动语义实现。
            * 
    模块间传输的数据结构不同，如何通用的解决
                * 
    模板化接口：从而可以通用的传输数据，比共享内存区域更好
                    * 
    师兄和Gem5使用的是两个模块之间加一个类似共享内存的区域传输：效率不高，以后更加细粒度的模块，那么中间共享的区域将会大大增加；不好维护。
            * 
    需要一个全局的性能监测组件，而全局变量不适合。
                * 
    借鉴系统设计中log模块的设计方案，使用单例模式而不是全局变量解决；
    * 
    为什么你做的项目没有什么关联性？
        1. 
    我希望多学各方面的知识，当然现在主要是系统的建模：比如说学习Git，在后来的工作中我负责代码库的维护；学习python也使得入手Django和一些python的项目可以无缝衔接
        1. 
    为什么你的项目都是导师或者师兄安排的？怎么突出自己的创新或者新奇点？？？
            * 
    采用单例模式而不是全局变量解决性能采集组件的设计
            * 
    使用类模板定义端口，而不是共享一个区域来传输数据。
    * 验证方案：
        * 模拟器中有自己的oracle系统，可以实时对比执行结果
        * 可以根据模拟器中事件发生的情况，与其他模拟器以及测试指令集指定的事件发生次数对比；
        * 监测同一个指令在指定的时间处在哪一个模块中。
    * 测试方案：
        * 每个子负责自己模块的验证
        * 最终模拟器组合，通过Log、PMU系统来评估整个模拟器的性能以及准确性
    * 性能评估和优化
        * 评估：
            * 精确性：和应有的结果做比较
            * 效率：时间和空间复杂度
        * 优化：
            * 时空复杂度：右值引用和转移语义
            * 我们设计的时候考虑到了不同的实现方案同时也考虑到了扩展性（比如模块基类，任何一个子模块都可以继承）、可配置性（根据配置文件进行修改）所以可以同时启动多个模拟器尝试不同的方案。
    * 
**总结：**
我们项目主要是模拟指令在CPU中整个pipeline的执行过程（取指、译码等）以及状态机的转换（寄存器值、标志位的改变、Cache替换情况等等），整个项目分为三个部分：前端（指令流被顺序的处理得到CPU可以直接执行的微操作），后端（乱序执行），内存模块（主要是Cache）；我主要负责的是后端乱序执行，我根据乱序执行的功能逻辑和过程将后端主要分为三个子模块：乱序的准备也就是说解决“false dependency”、乱序的执行即调度算法的实现（FIFO、优先级等）、顺序提交（前端来的虽然是微操作但是对于用户来说是以指令为单位的，那么我们提交的时候也是以指令为单位保证“precise interrupt”），每个模块负责自己的逻辑功能。模拟器的实现不是很复杂，主要是达到硬件的要求（比如硬件吞吐量、时序逻辑）：
        * 
怎么为乱序做准备即怎么解决寄存器的映射关系？首先要判断那些依赖是“false-dependency”？
            * 
RAR、RAW、WAW、WAR，除了最后一个写后读，其他都是“false-dependency”========》映射表记录，源操作数都是从表中读，目地操作数重新映射为一个新的物理寄存器。（即这张表记录的是最新的映射关系）
        * 
如何记录操作数之间的依赖关系？
            * 
uop与uop直接的依赖关系：维护复杂
            * 
uop与PR的依赖关系：空间大，但是维护简单
        * 
调度的时候寄存器值准备好了就能调度吗？
            * 
当然不是，还要考虑：运算单元有没有准备好、回写端口有没有准备好
        * 
顺序提交时指令的微操作数大于4个怎么办？
            * 
每一个微操作都记录自己是不是指令的头和尾：提交时如果是头，监测所有；如果不是直接提交因为上次已经检查过了
        * 
创新：
            * 
微操作的传递和管理权问题：
                * 
一般模拟器使用的是值传递，现在比较流行的模拟器使用的类似于共享区域的方式，上一个模块把处理结果放到两个模块之间的共享区，下一个模块读；
                    * 
优点是：方便
                    * 
缺点很多：每两个模块都是提前声明一个共享区域、下一个模块无法上一个模块通信、如果多线程会不会存在共同访问的问题
                * 
我们对每一个模块增加了若干个输出端口和若干的输入端口，每一个输入/输出端口都和对应模块的输出/输入端口绑定：输出端口负责保存本模块的处理结果，输入端口负责从绑定的输出端口上读取数据；同时使用move转移语义和智能指针解决对象、管理权传递和生存周期的问题。
                * 
实现**模块的即插即拔**特性：一个新的设计方案、一个新的替换算法、一个新的调度算法都可以十分方便的在本模拟器上实现
            * 
高可扩展：
                * 
我们有一个模块基类，里面声明了两个纯虚函数：一个负责读取，一个负责执行本模块的任务，对应了电路中的上升沿和下降沿。所有的模块都继承该类，子类只需要实现自己的功能络，添加自己的输入、输出端口，即可！
                * 
通过端口化，我们可以很方便的管理模块的增加和删除；很方便的实现对象的管理权传递和生存周期的问题；
1. 
海云存储项目：
    * 
介绍：主要是为了解决文件集中存储、共享及跨平台访问的问题。
    * 
主要的开发分为前后端两个：搭建基本的网站平台使用Django，而后端为了更好的效率使用C++开发。
        * 
为了熟悉基本的Django开发，以及熟悉系统的设计，参与用户角色的设计
        * 
由于前端或者说服务层是Django开发的，但是低层的服务是C/C++开发的，所以我们使用Glib库解决参数传递的问题
        * 
为了熟悉基础组件的开发，参与到了CDC分块算法中！VSP
    * 
分块的实现：
        * 
找每一块的边界：那些可以当作一个块的边界；记录每一个块的位移大小hash值，同时写到文件的hash值中
        * 
块最大、最小的问题
        * 
每一块分好之后，我们记录本块的hash值以及相对于整个文件的位移，同时记录整个文件的hansh值
        * 
当文件上传时，对比同一个文件的两个hash值，找到不同的hash值（因为整个文件的hansh值是所有块组合成）。从而得到不同处的位移，上传对应的块即可

[返回目录](README.md)