1. 
一个.c文件到.exe的过程
  * 预编译，展开C的头文件以及一些宏
  * 编译：语法检查等，得到汇编代码
  * 将汇编代码编译成目标代码，生成符号表、虚函数表等，
  * 链接形成可执行文件
1. 
堆和栈比较

1. 
c和C++比较
  * 最简单也就是C面向过程，强掉过程（算法和结构）---由输入经过计算得输出，C++面向对象，强掉设计 =====》所以开始时才有C++叫C-with-class
  * C++支持而C不支持：面向对象、继承、泛型技术、重载（普通和操作符）、STL等
  * C支持而C++不支持：很少
  * C和C++都支持但是语法不同：const、struct、void*、auto、IO
1. 
C++的锁有那些？以及区别
1. 
进程通信
1. 
单例模式
1. 
生产者-消费者  加锁
1. 
BOOL , float, 指针变量 与“零值”比较的 if 语句
```C
    解答：
    BOOL型变量：if（！var）
    int型变量： if（var==0）
    float型变量：
      const float EPSINON = 0.00001；
      if （（x >= - EPSINON） && （x <= EPSINON）
    指针变量：　if（var==NULL）```
* 
三种传参的不同、返回值的不同
* 
strlen（）的实现
* 
C语言参数的入栈顺序，为什么这样？
* 
C语言的字符串反转效率
* C语言main()中return和exit(x)的区别<br>
  * exit是系统调用，意味着进程的结束，不会触发退栈操作，将控制权交给系统或者父进程
  * return是C语言的函数调用它将触发退栈操作，将控制权交给调用函数。
* C的参数：
  ```C
  int a = 10,b = 20 , c = 30;
  printf("\n %d .. %d .. %d \n", a+b+c,(b = 2*b),(c = 2*30));
    =====> 110 .. 40 .. 60
  因为C中参数是从右向左来的！！！ 
  ```
* C++为什么支持重载，而C不支持<br>
  因为编译的时候，C只会关心名字而C++会将参数也加入编译，从而得到函数名，即便函数名相同，只要参数不同，它们的符号名是不会冲突的，所以可以重载
```C  
符号名就会按如下规则来处理
1、 符号以_Z开始
2、 如果有嵌套，后面紧跟N，然后是名称空间、类、函数的名字，名字前的数字是长度，以E结尾
3、 如果没嵌套，则直接是名字长度后面跟着名字
4、 最后是参数列表，类型和符号对应关系如下```




[返回目录](README.md)